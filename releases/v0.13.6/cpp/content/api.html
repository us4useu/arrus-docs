

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>C++ API Reference &mdash; ARRUS (cpp) 0.13.6 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Acknowledgments" href="misc/acknowledgments.html" />
    <link rel="prev" title="User Guide" href="user_guide.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> ARRUS (cpp)
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">User Documentation</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="definitions.html">Glossary and assumptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="user_guide.html">User Guide</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">C++ API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#notation">Notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#session">Session</a></li>
<li class="toctree-l2"><a class="reference internal" href="#operations">Operations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#scheme">Scheme</a></li>
<li class="toctree-l3"><a class="reference internal" href="#custom-tx-rx-sequences">Custom Tx/Rx sequences</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#devices">Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="#output-data">Output data</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Miscellaneous</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="misc/acknowledgments.html">Acknowledgments</a></li>
<li class="toctree-l1"><a class="reference internal" href="misc/release_notes.html">Release notes</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">ARRUS (cpp)</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>C++ API Reference</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="c-api-reference">
<span id="arrus-api"></span><h1>C++ API Reference<a class="headerlink" href="#c-api-reference" title="Permalink to this headline">¶</a></h1>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>ARRUS C++ API is currently under development and its API will be modified in the future. Please expect breaking changes.</p>
</div>
<div class="section" id="notation">
<h2>Notation<a class="headerlink" href="#notation" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Class::Handle</span></code> is a typedef for <code class="docutils literal notranslate"><span class="pre">std::unique_ptr&lt;Class&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Class::SharedHandle</span></code> is a typedef for <code class="docutils literal notranslate"><span class="pre">std::shared_ptr&lt;Class&gt;</span></code></p></li>
</ul>
</div>
<div class="section" id="session">
<h2>Session<a class="headerlink" href="#session" title="Permalink to this headline">¶</a></h2>
<dl class="cpp function">
<dt id="_CPPv4N5arrus7session13createSessionERKNSt6stringE">
<span id="_CPPv3N5arrus7session13createSessionERKNSt6stringE"></span><span id="_CPPv2N5arrus7session13createSessionERKNSt6stringE"></span><span id="arrus::session::createSession__ssCR"></span><span class="target" id="Session_8h_1afcd8168374171630bfd57b2c00b781dd"></span>ARRUS_CPP_EXPORT <a class="reference internal" href="#_CPPv4N5arrus7session7SessionE" title="arrus::session::Session">Session</a>::Handle <code class="sig-prename descclassname">arrus::session<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">createSession</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>filepath</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrus7session13createSessionERKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reads given configuration file and returns a handle to new session.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filepath</strong> – a path to session settings </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a unique handle to session </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrus7session7SessionE">
<span id="_CPPv3N5arrus7session7SessionE"></span><span id="_CPPv2N5arrus7session7SessionE"></span><span id="arrus::session::Session"></span><span class="target" id="classarrus_1_1session_1_1Session"></span><em class="property">class </em><code class="sig-prename descclassname">arrus::session<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">Session</code><a class="headerlink" href="#_CPPv4N5arrus7session7SessionE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A communication session with the device. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-types">Public Types</p>
<dl class="cpp enum-class">
<dt id="_CPPv4N5arrus7session7Session5StateE">
<span id="_CPPv3N5arrus7session7Session5StateE"></span><span id="_CPPv2N5arrus7session7Session5StateE"></span><span class="target" id="classarrus_1_1session_1_1Session_1aa26eb505d153010ff890301bcb338d64"></span><em class="property">enum class </em><code class="sig-name descname">State</code><a class="headerlink" href="#_CPPv4N5arrus7session7Session5StateE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#classarrus_1_1session_1_1Session"><span class="std std-ref">Session</span></a> state.</p>
<p><ul class="simple">
<li><p>STOPPED: the session is stopped (no device is running).</p></li>
<li><p>STARTED: the session is started (at least one of the session devices is running).</p></li>
<li><p>CLOSED: the session was closed (the connection to all the session devices was closed). </p></li>
</ul>
</p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt id="_CPPv4N5arrus7session7Session5State7STOPPEDE">
<span id="_CPPv3N5arrus7session7Session5State7STOPPEDE"></span><span id="_CPPv2N5arrus7session7Session5State7STOPPEDE"></span><span class="target" id="classarrus_1_1session_1_1Session_1aa26eb505d153010ff890301bcb338d64a09d4d696b4e935115b9313e3c412509a"></span><em class="property">enumerator </em><code class="sig-name descname">STOPPED</code><a class="headerlink" href="#_CPPv4N5arrus7session7Session5State7STOPPEDE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="cpp enumerator">
<dt id="_CPPv4N5arrus7session7Session5State7STARTEDE">
<span id="_CPPv3N5arrus7session7Session5State7STARTEDE"></span><span id="_CPPv2N5arrus7session7Session5State7STARTEDE"></span><span class="target" id="classarrus_1_1session_1_1Session_1aa26eb505d153010ff890301bcb338d64a17130e6c806885e23770df1519b18eb7"></span><em class="property">enumerator </em><code class="sig-name descname">STARTED</code><a class="headerlink" href="#_CPPv4N5arrus7session7Session5State7STARTEDE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="cpp enumerator">
<dt id="_CPPv4N5arrus7session7Session5State6CLOSEDE">
<span id="_CPPv3N5arrus7session7Session5State6CLOSEDE"></span><span id="_CPPv2N5arrus7session7Session5State6CLOSEDE"></span><span class="target" id="classarrus_1_1session_1_1Session_1aa26eb505d153010ff890301bcb338d64a110ccf2f5d2ff4eda1fd1a494293467d"></span><em class="property">enumerator </em><code class="sig-name descname">CLOSED</code><a class="headerlink" href="#_CPPv4N5arrus7session7Session5State6CLOSEDE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrus7session7Session9getDeviceERKNSt6stringE">
<span id="_CPPv3N5arrus7session7Session9getDeviceERKNSt6stringE"></span><span id="_CPPv2N5arrus7session7Session9getDeviceERKNSt6stringE"></span><span id="arrus::session::Session::getDevice__ssCR"></span><span class="target" id="classarrus_1_1session_1_1Session_1afd751885e2d92b5e0d1831bb7bb7f4ef"></span><em class="property">virtual</em> arrus::devices::Device *<code class="sig-name descname">getDevice</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>deviceId</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7session7Session9getDeviceERKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a handle to device with given Id. The string format is: /DeviceType:Ordinal, e.g. “/Us4R:0”.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>deviceId</strong> – device identifier </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a handle to the device </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7session7Session9getDeviceERKN5arrus7devices8DeviceIdE">
<span id="_CPPv3N5arrus7session7Session9getDeviceERKN5arrus7devices8DeviceIdE"></span><span id="_CPPv2N5arrus7session7Session9getDeviceERKN5arrus7devices8DeviceIdE"></span><span id="arrus::session::Session::getDevice__arrus::devices::DeviceIdCR"></span><span class="target" id="classarrus_1_1session_1_1Session_1a74305ff1c9cf38b4afd7a64cff008bb3"></span><em class="property">virtual</em> arrus::devices::Device *<code class="sig-name descname">getDevice</code><span class="sig-paren">(</span><em class="property">const</em> arrus::devices::DeviceId &amp;<em>deviceId</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7session7Session9getDeviceERKN5arrus7devices8DeviceIdE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a handle to device with given Id.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>deviceId</strong> – device identifier </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a handle to the device </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7session7Session6uploadERKN5arrus3ops4us4r6SchemeE">
<span id="_CPPv3N5arrus7session7Session6uploadERKN5arrus3ops4us4r6SchemeE"></span><span id="_CPPv2N5arrus7session7Session6uploadERKN5arrus3ops4us4r6SchemeE"></span><span id="arrus::session::Session::upload__arrus::ops::us4r::SchemeCR"></span><span class="target" id="classarrus_1_1session_1_1Session_1a2e1909256cce88d4d564f5984a9df1b9"></span><em class="property">virtual</em> <a class="reference internal" href="#_CPPv4N5arrus7session12UploadResultE" title="arrus::session::UploadResult">UploadResult</a> <code class="sig-name descname">upload</code><span class="sig-paren">(</span><em class="property">const</em> ::arrus::ops::us4r::<a class="reference internal" href="#_CPPv4N5arrus3ops4us4r6SchemeE" title="arrus::ops::us4r::Scheme">Scheme</a> &amp;<em>scheme</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7session7Session6uploadERKN5arrus3ops4us4r6SchemeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Uploads a given scheme on the available devices.</p>
<p>Currently, the scheme upload is performed on the Us4R:0 device only.</p>
<p>After uploading a new sequence the previously returned output buffers will be in invalid state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>scheme</strong> – scheme to upload </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>upload result information </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7session7Session11startSchemeEv">
<span id="_CPPv3N5arrus7session7Session11startSchemeEv"></span><span id="_CPPv2N5arrus7session7Session11startSchemeEv"></span><span id="arrus::session::Session::startScheme"></span><span class="target" id="classarrus_1_1session_1_1Session_1acb981f6bd8bf597cda3740739dcfcb7f"></span><em class="property">virtual</em> void <code class="sig-name descname">startScheme</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7session7Session11startSchemeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Starts currently uploaded scheme. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7session7Session10stopSchemeEv">
<span id="_CPPv3N5arrus7session7Session10stopSchemeEv"></span><span id="_CPPv2N5arrus7session7Session10stopSchemeEv"></span><span id="arrus::session::Session::stopScheme"></span><span class="target" id="classarrus_1_1session_1_1Session_1a1a16c6a7020361932f4e3d332f7a765f"></span><em class="property">virtual</em> void <code class="sig-name descname">stopScheme</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7session7Session10stopSchemeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Stops currently uploaded scheme. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7session7Session3runEbNSt8optionalIxEE">
<span id="_CPPv3N5arrus7session7Session3runEbNSt8optionalIxEE"></span><span id="_CPPv2N5arrus7session7Session3runEbNSt8optionalIxEE"></span><span id="arrus::session::Session::run__b.std::optional:l-l:"></span><span class="target" id="classarrus_1_1session_1_1Session_1ae051c162f66005b11851c959850b2e45"></span><em class="property">virtual</em> void <code class="sig-name descname">run</code><span class="sig-paren">(</span>bool <em>sync</em> = false, std::optional&lt;long long&gt; <em>timeout</em> = std::nullopt<span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7session7Session3runEbNSt8optionalIxEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Runs the uploaded scheme.</p>
<p>The behaviour of this method depends on the work mode:<ul class="simple">
<li><p>MANUAL: triggers execution of batch of sequences only ONCE,</p></li>
<li><p>MANUAL_OP: triggers execution of a single TX/RX only ONCE,</p></li>
<li><p>HOST, ASYNC: triggers execution of batch of sequences IN A LOOP (Host: trigger is on buffer element release). The run function can be called only once (before the scheme is stopped).</p></li>
</ul>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sync</strong> – whether this method should work in a synchronous or asynchronous; true means synchronous, i.e. the caller will wait until the triggered TX/RX or sequence of TX/RXs has been done. The sync = true is only allowed when the work mode is set to MANUAL or MANUAL_OP. NOTE: For the US4R device, this method ONLY waits for the completion of the TX/RX sequence. Currently, it DOES NOT WAIT for the data transfer to the host PC or for the processing to finish — to wait for these two events, either wait for the final data using buffer.get(), or register your own callback function. </p></li>
<li><p><strong>timeout</strong> – timeout [ms]; std::nullopt means to wait infinitely. This parameter is only relevant when sync = true; the value of this parameter only matters when work mode is set to MANUAL or MANUAL_OP </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7session7Session5closeEv">
<span id="_CPPv3N5arrus7session7Session5closeEv"></span><span id="_CPPv2N5arrus7session7Session5closeEv"></span><span id="arrus::session::Session::close"></span><span class="target" id="classarrus_1_1session_1_1Session_1a18d63f068adf200991cbd0048fa9c1c7"></span><em class="property">virtual</em> void <code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7session7Session5closeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Closes session.</p>
<p>This method disconnects with all the devices available during this session. Sets the state of the session to closed, any subsequent call to the object methods (e.g. upload, startScheme..) will result in InvalidStateException. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7session7Session15getCurrentStateEv">
<span id="_CPPv3N5arrus7session7Session15getCurrentStateEv"></span><span id="_CPPv2N5arrus7session7Session15getCurrentStateEv"></span><span id="arrus::session::Session::getCurrentState"></span><span class="target" id="classarrus_1_1session_1_1Session_1a811ffb14d932a94269045e3bc9f0066c"></span><em class="property">virtual</em> <a class="reference internal" href="#_CPPv4N5arrus7session7Session5StateE" title="arrus::session::Session::State">State</a> <code class="sig-name descname">getCurrentState</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7session7Session15getCurrentStateEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the current state of the session. See also <a class="reference internal" href="#classarrus_1_1session_1_1Session_1aa26eb505d153010ff890301bcb338d64"><span class="std std-ref">Session::State</span></a>. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7session7Session14setSubsequenceE6uint166uint16NSt8optionalIfEE6uint16">
<span id="_CPPv3N5arrus7session7Session14setSubsequenceE6uint166uint16NSt8optionalIfEE6uint16"></span><span id="_CPPv2N5arrus7session7Session14setSubsequenceE6uint166uint16NSt8optionalIfEE6uint16"></span><span id="arrus::session::Session::setSubsequence__uint16.uint16.std::optional:float:.uint16"></span><span class="target" id="classarrus_1_1session_1_1Session_1ada91999d313b8b74a5e87f91b6ca4036"></span><em class="property">virtual</em> <a class="reference internal" href="#_CPPv4N5arrus7session12UploadResultE" title="arrus::session::UploadResult">UploadResult</a> <code class="sig-name descname">setSubsequence</code><span class="sig-paren">(</span>uint16 <em>start</em>, uint16 <em>end</em>, std::optional&lt;float&gt; <em>sri</em>, uint16 <em>arrayId</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7session7Session14setSubsequenceE6uint166uint16NSt8optionalIfEE6uint16" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Turns on the sequence with the arrayId and sets the TX/RXs to the [start, end) range. This method turns off all the uploaded TX/RX sequences except sequence pointed by <code class="docutils literal notranslate"><span class="pre">arrayId</span></code>.</p>
<p>This method requires that:</p>
<p><ul class="simple">
<li><p>start &lt; end (start == end would mean that the given sequence should bet turned off, and that would mean that all TX/RXs sequences should be turned off, which current does not make sense),</p></li>
<li><p>the scheme was uploaded,</p></li>
<li><p>the TX/RX sequence length is greater than the <code class="docutils literal notranslate"><span class="pre">end</span></code> value,</p></li>
<li><p>the scheme is stopped.</p></li>
</ul>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start</strong> – the TX/RX number which should now be the first TX/RX </p></li>
<li><p><strong>end</strong> – the TX/RX number which should now be the last TX/RX </p></li>
<li><p><strong>sri</strong> – the new SRI to apply </p></li>
<li><p><strong>arrayId</strong> – id array to select, default: array with id 0 </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the new data buffer and metadata </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7session7Session15setSubsequencesERKNSt6vectorI5SliceEERKNSt6vectorINSt8optionalIfEEEE">
<span id="_CPPv3N5arrus7session7Session15setSubsequencesERKNSt6vectorI5SliceEERKNSt6vectorINSt8optionalIfEEEE"></span><span id="_CPPv2N5arrus7session7Session15setSubsequencesERKNSt6vectorI5SliceEERKNSt6vectorINSt8optionalIfEEEE"></span><span id="arrus::session::Session::setSubsequences__std::vector:Slice:CR.std::vector:std::optional:float::CR"></span><span class="target" id="classarrus_1_1session_1_1Session_1a3c85491bbe08be685e56c5edd0d05c14"></span><em class="property">virtual</em> <a class="reference internal" href="#_CPPv4N5arrus7session12UploadResultE" title="arrus::session::UploadResult">UploadResult</a> <code class="sig-name descname">setSubsequences</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;Slice&gt; &amp;<em>slices</em>, <em class="property">const</em> std::vector&lt;std::optional&lt;float&gt;&gt; &amp;<em>sris</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7session7Session15setSubsequencesERKNSt6vectorI5SliceEERKNSt6vectorINSt8optionalIfEEEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Selects [start, end) slices for each sub-sequence.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">slices</span></code> array should have exactly n elements, where n is the number of currently uploaded sequences. The element slice[i] sets the [start, end) range for the i-th sequence.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">sris</span></code> should have eactly n elements, or should be empty (which means that no additional sri should be applied).</p>
<p>To turn off the given sequence, just set start equal to end (e.g. Slice(0, 0)). For such sequences, the metadata will</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>slices</strong> – slices to set to each Scheme sub-sequence </p></li>
<li><p><strong>sris</strong> – sris to apply to each Scheme sub-sequence </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>returns the buffer and metadata for the modified Scheme. The metadata array size is always equal to the number of seqeuences in the original Scheme </p>
</dd>
</dl>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-static-functions">Public Static Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrus7session7Session23getSessionStateAsStringEK5State">
<span id="_CPPv3N5arrus7session7Session23getSessionStateAsStringEK5State"></span><span id="_CPPv2N5arrus7session7Session23getSessionStateAsStringEK5State"></span><span id="arrus::session::Session::getSessionStateAsString__StateC"></span><span class="target" id="classarrus_1_1session_1_1Session_1acb30b7266cd752cc4df7e5776986fc21"></span><em class="property">static</em> <em class="property">inline</em> std::string <code class="sig-name descname">getSessionStateAsString</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrus7session7Session5StateE" title="arrus::session::Session::State">State</a> <em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrus7session7Session23getSessionStateAsStringEK5State" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a <a class="reference internal" href="#classarrus_1_1session_1_1Session"><span class="std std-ref">Session</span></a> State name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>state</strong> – <a class="reference internal" href="#classarrus_1_1session_1_1Session"><span class="std std-ref">Session</span></a> State </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a <a class="reference internal" href="#classarrus_1_1session_1_1Session"><span class="std std-ref">Session</span></a> State name (string) </p>
</dd>
</dl>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="operations">
<h2>Operations<a class="headerlink" href="#operations" title="Permalink to this headline">¶</a></h2>
<div class="section" id="scheme">
<h3>Scheme<a class="headerlink" href="#scheme" title="Permalink to this headline">¶</a></h3>
<dl class="cpp class">
<dt id="_CPPv4N5arrus3ops4us4r6SchemeE">
<span id="_CPPv3N5arrus3ops4us4r6SchemeE"></span><span id="_CPPv2N5arrus3ops4us4r6SchemeE"></span><span id="arrus::ops::us4r::Scheme"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1Scheme"></span><em class="property">class </em><code class="sig-prename descclassname">arrus::ops::us4r<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">Scheme</code><a class="headerlink" href="#_CPPv4N5arrus3ops4us4r6SchemeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A scheme to be executed within the session. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-types">Public Types</p>
<dl class="cpp enum-class">
<dt id="_CPPv4N5arrus3ops4us4r6Scheme8WorkModeE">
<span id="_CPPv3N5arrus3ops4us4r6Scheme8WorkModeE"></span><span id="_CPPv2N5arrus3ops4us4r6Scheme8WorkModeE"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1Scheme_1adcc0cdfe772506d3705979654cadde68"></span><em class="property">enum class </em><code class="sig-name descname">WorkMode</code><a class="headerlink" href="#_CPPv4N5arrus3ops4us4r6Scheme8WorkModeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>How the scheme should be executed on the us4r-lite device.</p>
<p>This enum value determines the source of the signal trigger (i.e. whether the signal is triggered by us4oem modules or host PC). </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt id="_CPPv4N5arrus3ops4us4r6Scheme8WorkMode5ASYNCE">
<span id="_CPPv3N5arrus3ops4us4r6Scheme8WorkMode5ASYNCE"></span><span id="_CPPv2N5arrus3ops4us4r6Scheme8WorkMode5ASYNCE"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1Scheme_1adcc0cdfe772506d3705979654cadde68abe553330beb7b3d994656e0a4e66cd96"></span><em class="property">enumerator </em><code class="sig-name descname">ASYNC</code><a class="headerlink" href="#_CPPv4N5arrus3ops4us4r6Scheme8WorkMode5ASYNCE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Trigger generated by us4r, error on overflow. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt id="_CPPv4N5arrus3ops4us4r6Scheme8WorkMode4SYNCE">
<span id="_CPPv3N5arrus3ops4us4r6Scheme8WorkMode4SYNCE"></span><span id="_CPPv2N5arrus3ops4us4r6Scheme8WorkMode4SYNCE"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1Scheme_1adcc0cdfe772506d3705979654cadde68a274ccef15a21e829d03293a6fd1974f3"></span><em class="property">enumerator </em><code class="sig-name descname">SYNC</code><a class="headerlink" href="#_CPPv4N5arrus3ops4us4r6Scheme8WorkMode4SYNCE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Trigger generated by us4r, us4r waits on overflow </p>
</dd></dl>

<dl class="cpp enumerator">
<dt id="_CPPv4N5arrus3ops4us4r6Scheme8WorkMode4HOSTE">
<span id="_CPPv3N5arrus3ops4us4r6Scheme8WorkMode4HOSTE"></span><span id="_CPPv2N5arrus3ops4us4r6Scheme8WorkMode4HOSTE"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1Scheme_1adcc0cdfe772506d3705979654cadde68ab9361011891280a44d85b967739cc6a5"></span><em class="property">enumerator </em><code class="sig-name descname">HOST</code><a class="headerlink" href="#_CPPv4N5arrus3ops4us4r6Scheme8WorkMode4HOSTE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Trigger generated by host, no error on overflow. DEPRECATED: will be replaced in the future by MANUAL mode </p>
</dd></dl>

<dl class="cpp enumerator">
<dt id="_CPPv4N5arrus3ops4us4r6Scheme8WorkMode6MANUALE">
<span id="_CPPv3N5arrus3ops4us4r6Scheme8WorkMode6MANUALE"></span><span id="_CPPv2N5arrus3ops4us4r6Scheme8WorkMode6MANUALE"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1Scheme_1adcc0cdfe772506d3705979654cadde68aa60a6a471c0681e5a49c4f5d00f6bc5a"></span><em class="property">enumerator </em><code class="sig-name descname">MANUAL</code><a class="headerlink" href="#_CPPv4N5arrus3ops4us4r6Scheme8WorkMode6MANUALE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>New data acquisition and processing is manually triggered by user. The systems stops per sequence execution. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt id="_CPPv4N5arrus3ops4us4r6Scheme8WorkMode9MANUAL_OPE">
<span id="_CPPv3N5arrus3ops4us4r6Scheme8WorkMode9MANUAL_OPE"></span><span id="_CPPv2N5arrus3ops4us4r6Scheme8WorkMode9MANUAL_OPE"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1Scheme_1adcc0cdfe772506d3705979654cadde68a9044a8aed27ef95efdc5eb09c3c0f4b8"></span><em class="property">enumerator </em><code class="sig-name descname">MANUAL_OP</code><a class="headerlink" href="#_CPPv4N5arrus3ops4us4r6Scheme8WorkMode9MANUAL_OPE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>New data acquisition and processing is manually triggered by user. The systems stops per TX/RX execution. </p>
</dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4NK5arrus3ops4us4r6Scheme16isWorkModeManualEv">
<span id="_CPPv3NK5arrus3ops4us4r6Scheme16isWorkModeManualEv"></span><span id="_CPPv2NK5arrus3ops4us4r6Scheme16isWorkModeManualEv"></span><span id="arrus::ops::us4r::Scheme::isWorkModeManualC"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1Scheme_1aa5f6489db9bad5938eca867dd5cfa324"></span><em class="property">inline</em> bool <code class="sig-name descname">isWorkModeManual</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrus3ops4us4r6Scheme16isWorkModeManualEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if the work mode is MANUAL (MANUAL per sequence or MANUAL_TX_RX (per TX/RX). </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus3ops4us4r6Scheme6SchemeE12TxRxSequence6uint16RKN9framework14DataBufferSpecE8WorkModeNSt8optionalI21DigitalDownConversionEERKNSt6vectorIN5arrus9framework7NdArrayEEE">
<span id="_CPPv3N5arrus3ops4us4r6Scheme6SchemeE12TxRxSequence6uint16RKN9framework14DataBufferSpecE8WorkModeNSt8optionalI21DigitalDownConversionEERKNSt6vectorIN5arrus9framework7NdArrayEEE"></span><span id="_CPPv2N5arrus3ops4us4r6Scheme6SchemeE12TxRxSequence6uint16RKN9framework14DataBufferSpecE8WorkModeNSt8optionalI21DigitalDownConversionEERKNSt6vectorIN5arrus9framework7NdArrayEEE"></span><span id="arrus::ops::us4r::Scheme::Scheme__TxRxSequence.uint16.framework::DataBufferSpecCR.WorkMode.std::optional:DigitalDownConversion:.std::vector:arrus::framework::NdArray:CR"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1Scheme_1aa1d4588dd5ead405dc12fee2de9ff0ea"></span>ARRUS_CPP_EXPORT <code class="sig-name descname">Scheme</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N5arrus3ops4us4r12TxRxSequenceE" title="arrus::ops::us4r::TxRxSequence">TxRxSequence</a> <em>txRxSequence</em>, uint16 <em>rxBufferSize</em>, <em class="property">const</em> framework::<a class="reference internal" href="#_CPPv4N5arrus9framework14DataBufferSpecE" title="arrus::framework::DataBufferSpec">DataBufferSpec</a> &amp;<em>outputBuffer</em>, <a class="reference internal" href="#_CPPv4N5arrus3ops4us4r6Scheme8WorkModeE" title="arrus::ops::us4r::Scheme::WorkMode">WorkMode</a> <em>workMode</em>, std::optional&lt;<a class="reference internal" href="#_CPPv4N5arrus3ops4us4r21DigitalDownConversionE" title="arrus::ops::us4r::DigitalDownConversion">DigitalDownConversion</a>&gt; <em>ddc</em>, <em class="property">const</em> std::vector&lt;arrus::framework::<a class="reference internal" href="#_CPPv4N5arrus9framework7NdArrayE" title="arrus::framework::NdArray">NdArray</a>&gt; &amp;<em>constants</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrus3ops4us4r6Scheme6SchemeE12TxRxSequence6uint16RKN9framework14DataBufferSpecE8WorkModeNSt8optionalI21DigitalDownConversionEERKNSt6vectorIN5arrus9framework7NdArrayEEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>TODO(0.12.0) Deprecated: please use Scheme::create instead </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus3ops4us4r6Scheme6SchemeE12TxRxSequence6uint16RKN9framework14DataBufferSpecE8WorkMode">
<span id="_CPPv3N5arrus3ops4us4r6Scheme6SchemeE12TxRxSequence6uint16RKN9framework14DataBufferSpecE8WorkMode"></span><span id="_CPPv2N5arrus3ops4us4r6Scheme6SchemeE12TxRxSequence6uint16RKN9framework14DataBufferSpecE8WorkMode"></span><span id="arrus::ops::us4r::Scheme::Scheme__TxRxSequence.uint16.framework::DataBufferSpecCR.WorkMode"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1Scheme_1a97493a1512a27d85137d91274516abfe"></span>ARRUS_CPP_EXPORT <em class="property">inline</em> <code class="sig-name descname">Scheme</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N5arrus3ops4us4r12TxRxSequenceE" title="arrus::ops::us4r::TxRxSequence">TxRxSequence</a> <em>txRxSequence</em>, uint16 <em>rxBufferSize</em>, <em class="property">const</em> framework::<a class="reference internal" href="#_CPPv4N5arrus9framework14DataBufferSpecE" title="arrus::framework::DataBufferSpec">DataBufferSpec</a> &amp;<em>outputBuffer</em>, <a class="reference internal" href="#_CPPv4N5arrus3ops4us4r6Scheme8WorkModeE" title="arrus::ops::us4r::Scheme::WorkMode">WorkMode</a> <em>workMode</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrus3ops4us4r6Scheme6SchemeE12TxRxSequence6uint16RKN9framework14DataBufferSpecE8WorkMode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#classarrus_1_1ops_1_1us4r_1_1Scheme"><span class="std std-ref">Scheme</span></a> constructor. This scheme turns off hardware IQ demodulator. TODO(0.12.0) Deprecated: please use Scheme::create instead</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>txRxSequence</strong> – tx/rx sequence to perform </p></li>
<li><p><strong>rxBufferSize</strong> – the size of the data acquisition buffer in the memory of the Us4R device (a single element of the buffer is an output of a single tx/rx sequence execution) </p></li>
<li><p><strong>outputBuffer</strong> – output buffer specification </p></li>
<li><p><strong>workMode</strong> – scheme work mode </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus3ops4us4r6Scheme6SchemeE12TxRxSequence6uint16RKN9framework14DataBufferSpecE8WorkMode21DigitalDownConversion">
<span id="_CPPv3N5arrus3ops4us4r6Scheme6SchemeE12TxRxSequence6uint16RKN9framework14DataBufferSpecE8WorkMode21DigitalDownConversion"></span><span id="_CPPv2N5arrus3ops4us4r6Scheme6SchemeE12TxRxSequence6uint16RKN9framework14DataBufferSpecE8WorkMode21DigitalDownConversion"></span><span id="arrus::ops::us4r::Scheme::Scheme__TxRxSequence.uint16.framework::DataBufferSpecCR.WorkMode.DigitalDownConversion"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1Scheme_1a1a7c2ef0ca5128bb3937cd053c13e97b"></span>ARRUS_CPP_EXPORT <em class="property">inline</em> <code class="sig-name descname">Scheme</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N5arrus3ops4us4r12TxRxSequenceE" title="arrus::ops::us4r::TxRxSequence">TxRxSequence</a> <em>txRxSequence</em>, uint16 <em>rxBufferSize</em>, <em class="property">const</em> framework::<a class="reference internal" href="#_CPPv4N5arrus9framework14DataBufferSpecE" title="arrus::framework::DataBufferSpec">DataBufferSpec</a> &amp;<em>outputBuffer</em>, <a class="reference internal" href="#_CPPv4N5arrus3ops4us4r6Scheme8WorkModeE" title="arrus::ops::us4r::Scheme::WorkMode">WorkMode</a> <em>workMode</em>, <a class="reference internal" href="#_CPPv4N5arrus3ops4us4r21DigitalDownConversionE" title="arrus::ops::us4r::DigitalDownConversion">DigitalDownConversion</a> <em>ddc</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrus3ops4us4r6Scheme6SchemeE12TxRxSequence6uint16RKN9framework14DataBufferSpecE8WorkMode21DigitalDownConversion" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#classarrus_1_1ops_1_1us4r_1_1Scheme"><span class="std std-ref">Scheme</span></a> constructor. This scheme turns on hardware IQ demodulator (sees digital down conversion parameter).</p>
<p>TODO(0.12.0) Deprecated: please use Scheme::create instead</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>txRxSequence</strong> – tx/rx sequence to perform </p></li>
<li><p><strong>rxBufferSize</strong> – the size of the data acquisition buffer in the memory of the Us4R device (a single element of the buffer is an output of a single tx/rx sequence execution) </p></li>
<li><p><strong>outputBuffer</strong> – output buffer specification </p></li>
<li><p><strong>workMode</strong> – scheme work mode </p></li>
<li><p><strong>digitalDownConversion</strong> – DDC parameters </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus3ops4us4r6Scheme6SchemeE12TxRxSequence6uint16RKN9framework14DataBufferSpecE8WorkModeRKNSt6vectorIN9framework7NdArrayEEE">
<span id="_CPPv3N5arrus3ops4us4r6Scheme6SchemeE12TxRxSequence6uint16RKN9framework14DataBufferSpecE8WorkModeRKNSt6vectorIN9framework7NdArrayEEE"></span><span id="_CPPv2N5arrus3ops4us4r6Scheme6SchemeE12TxRxSequence6uint16RKN9framework14DataBufferSpecE8WorkModeRKNSt6vectorIN9framework7NdArrayEEE"></span><span id="arrus::ops::us4r::Scheme::Scheme__TxRxSequence.uint16.framework::DataBufferSpecCR.WorkMode.std::vector:framework::NdArray:CR"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1Scheme_1adcb1d0472afe775edf9790a1ddd5d1bb"></span>ARRUS_CPP_EXPORT <em class="property">inline</em> <code class="sig-name descname">Scheme</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N5arrus3ops4us4r12TxRxSequenceE" title="arrus::ops::us4r::TxRxSequence">TxRxSequence</a> <em>txRxSequence</em>, uint16 <em>rxBufferSize</em>, <em class="property">const</em> framework::<a class="reference internal" href="#_CPPv4N5arrus9framework14DataBufferSpecE" title="arrus::framework::DataBufferSpec">DataBufferSpec</a> &amp;<em>outputBuffer</em>, <a class="reference internal" href="#_CPPv4N5arrus3ops4us4r6Scheme8WorkModeE" title="arrus::ops::us4r::Scheme::WorkMode">WorkMode</a> <em>workMode</em>, <em class="property">const</em> std::vector&lt;framework::<a class="reference internal" href="#_CPPv4N5arrus9framework7NdArrayE" title="arrus::framework::NdArray">NdArray</a>&gt; &amp;<em>constants</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrus3ops4us4r6Scheme6SchemeE12TxRxSequence6uint16RKN9framework14DataBufferSpecE8WorkModeRKNSt6vectorIN9framework7NdArrayEEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>TODO(0.12.0) Deprecated: please use Scheme::create instead </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus3ops4us4r6Scheme15getTxRxSequenceEv">
<span id="_CPPv3NK5arrus3ops4us4r6Scheme15getTxRxSequenceEv"></span><span id="_CPPv2NK5arrus3ops4us4r6Scheme15getTxRxSequenceEv"></span><span id="arrus::ops::us4r::Scheme::getTxRxSequenceC"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1Scheme_1aab1210a1d26490c9d1dd16a0bd4093e1"></span>ARRUS_CPP_EXPORT <em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrus3ops4us4r12TxRxSequenceE" title="arrus::ops::us4r::TxRxSequence">TxRxSequence</a> &amp;<code class="sig-name descname">getTxRxSequence</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrus3ops4us4r6Scheme15getTxRxSequenceEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>TODO(0.12.0) Deprecated: please use getTxRxSequence(int ordinal) instead </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-static-functions">Public Static Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrus3ops4us4r6Scheme16isWorkModeManualE8WorkMode">
<span id="_CPPv3N5arrus3ops4us4r6Scheme16isWorkModeManualE8WorkMode"></span><span id="_CPPv2N5arrus3ops4us4r6Scheme16isWorkModeManualE8WorkMode"></span><span id="arrus::ops::us4r::Scheme::isWorkModeManual__WorkMode"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1Scheme_1a8bce324a898b229812e4c9d14ab1b4cd"></span><em class="property">static</em> <em class="property">inline</em> bool <code class="sig-name descname">isWorkModeManual</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N5arrus3ops4us4r6Scheme8WorkModeE" title="arrus::ops::us4r::Scheme::WorkMode">WorkMode</a> <em>workMode</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrus3ops4us4r6Scheme16isWorkModeManualE8WorkMode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if the work mode is MANUAL (MANUAL per sequence or MANUAL_TX_RX (per TX/RX). </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrus9framework14DataBufferSpecE">
<span id="_CPPv3N5arrus9framework14DataBufferSpecE"></span><span id="_CPPv2N5arrus9framework14DataBufferSpecE"></span><span id="arrus::framework::DataBufferSpec"></span><span class="target" id="classarrus_1_1framework_1_1DataBufferSpec"></span><em class="property">class </em><code class="sig-prename descclassname">arrus::framework<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">DataBufferSpec</code><a class="headerlink" href="#_CPPv4N5arrus9framework14DataBufferSpecE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Class describing output data buffer properties. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-types">Public Types</p>
<dl class="cpp enum-class">
<dt id="_CPPv4N5arrus9framework14DataBufferSpec4TypeE">
<span id="_CPPv3N5arrus9framework14DataBufferSpec4TypeE"></span><span id="_CPPv2N5arrus9framework14DataBufferSpec4TypeE"></span><span class="target" id="classarrus_1_1framework_1_1DataBufferSpec_1aebe1e1e1308c7d6853d97e1377ad3f1c"></span><em class="property">enum class </em><code class="sig-name descname">Type</code><a class="headerlink" href="#_CPPv4N5arrus9framework14DataBufferSpec4TypeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Buffer type. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt id="_CPPv4N5arrus9framework14DataBufferSpec4Type4FIFOE">
<span id="_CPPv3N5arrus9framework14DataBufferSpec4Type4FIFOE"></span><span id="_CPPv2N5arrus9framework14DataBufferSpec4Type4FIFOE"></span><span class="target" id="classarrus_1_1framework_1_1DataBufferSpec_1aebe1e1e1308c7d6853d97e1377ad3f1cac589858dbe1d06c46544266ae4cd2c6f"></span><em class="property">enumerator </em><code class="sig-name descname">FIFO</code><a class="headerlink" href="#_CPPv4N5arrus9framework14DataBufferSpec4Type4FIFOE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>First in first out buffer. </p>
</dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrus9framework14DataBufferSpec14DataBufferSpecE4TypeRKj">
<span id="_CPPv3N5arrus9framework14DataBufferSpec14DataBufferSpecE4TypeRKj"></span><span id="_CPPv2N5arrus9framework14DataBufferSpec14DataBufferSpecE4TypeRKj"></span><span id="arrus::framework::DataBufferSpec::DataBufferSpec__Type.unsignedCR"></span><span class="target" id="classarrus_1_1framework_1_1DataBufferSpec_1addc727f138b0934fad42ee62cc4d8a28"></span><em class="property">inline</em> <code class="sig-name descname">DataBufferSpec</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N5arrus9framework14DataBufferSpec4TypeE" title="arrus::framework::DataBufferSpec::Type">Type</a> <em>bufferType</em>, <em class="property">const</em> unsigned &amp;<em>nElements</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrus9framework14DataBufferSpec14DataBufferSpecE4TypeRKj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Data buffer specification constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bufferType</strong> – buffer type </p></li>
<li><p><strong>nElements</strong> – number of elements (a single element of the buffer is an output of a single tx/rx sequence execution) </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus9framework14DataBufferSpec19getNumberOfElementsEv">
<span id="_CPPv3NK5arrus9framework14DataBufferSpec19getNumberOfElementsEv"></span><span id="_CPPv2NK5arrus9framework14DataBufferSpec19getNumberOfElementsEv"></span><span id="arrus::framework::DataBufferSpec::getNumberOfElementsC"></span><span class="target" id="classarrus_1_1framework_1_1DataBufferSpec_1a89eda08441ec6a9ace681a435b376282"></span><em class="property">inline</em> unsigned <code class="sig-name descname">getNumberOfElements</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrus9framework14DataBufferSpec19getNumberOfElementsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns number of elements the buffer consists of. </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="custom-tx-rx-sequences">
<h3>Custom Tx/Rx sequences<a class="headerlink" href="#custom-tx-rx-sequences" title="Permalink to this headline">¶</a></h3>
<dl class="cpp class">
<dt id="_CPPv4N5arrus3ops4us4r12TxRxSequenceE">
<span id="_CPPv3N5arrus3ops4us4r12TxRxSequenceE"></span><span id="_CPPv2N5arrus3ops4us4r12TxRxSequenceE"></span><span id="arrus::ops::us4r::TxRxSequence"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1TxRxSequence"></span><em class="property">class </em><code class="sig-prename descclassname">arrus::ops::us4r<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">TxRxSequence</code><a class="headerlink" href="#_CPPv4N5arrus3ops4us4r12TxRxSequenceE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrus3ops4us4r12TxRxSequence12TxRxSequenceENSt6vectorI4TxRxEE8TGCCurvef5int16NSt6stringE">
<span id="_CPPv3N5arrus3ops4us4r12TxRxSequence12TxRxSequenceENSt6vectorI4TxRxEE8TGCCurvef5int16NSt6stringE"></span><span id="_CPPv2N5arrus3ops4us4r12TxRxSequence12TxRxSequenceENSt6vectorI4TxRxEE8TGCCurvef5int16NSt6stringE"></span><span id="arrus::ops::us4r::TxRxSequence::TxRxSequence__std::vector:TxRx:.TGCCurve.float.int16.ss"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1TxRxSequence_1aff75cef686f5244024012ed65874307e"></span><em class="property">inline</em> <code class="sig-name descname">TxRxSequence</code><span class="sig-paren">(</span>std::vector&lt;<a class="reference internal" href="#_CPPv4N5arrus3ops4us4r4TxRxE" title="arrus::ops::us4r::TxRx">TxRx</a>&gt; <em>sequence</em>, <a class="reference internal" href="#_CPPv4N5arrus3ops4us4r8TGCCurveE" title="arrus::ops::us4r::TGCCurve">TGCCurve</a> <em>tgcCurve</em>, float <em>sri</em> = NO_SRI, int16 <em>nRepeats</em> = 1, std::string <em>name</em> = &quot;&quot;<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrus3ops4us4r12TxRxSequence12TxRxSequenceENSt6vectorI4TxRxEE8TGCCurvef5int16NSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Tx/Rx sequence to execute on Us4R device.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sequence</strong> – a list of tx/rxs that compose a given sequence </p></li>
<li><p><strong>tgcCurve</strong> – tgc curve to apply </p></li>
<li><p><strong>sri</strong> – sequence repetition interval - the total time that a given sequence should take. </p></li>
<li><p><strong>nRepeats</strong> – - the number of repetitions of a given sequence. Determines the size of the batch </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus3ops4us4r12TxRxSequence6getOpsEv">
<span id="_CPPv3NK5arrus3ops4us4r12TxRxSequence6getOpsEv"></span><span id="_CPPv2NK5arrus3ops4us4r12TxRxSequence6getOpsEv"></span><span id="arrus::ops::us4r::TxRxSequence::getOpsC"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1TxRxSequence_1a5966998860191e9bd458d5d11aa5871b"></span><em class="property">inline</em> <em class="property">const</em> std::vector&lt;<a class="reference internal" href="#_CPPv4N5arrus3ops4us4r4TxRxE" title="arrus::ops::us4r::TxRx">TxRx</a>&gt; &amp;<code class="sig-name descname">getOps</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrus3ops4us4r12TxRxSequence6getOpsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns vector of operations to perform. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus3ops4us4r12TxRxSequence11getTgcCurveEv">
<span id="_CPPv3NK5arrus3ops4us4r12TxRxSequence11getTgcCurveEv"></span><span id="_CPPv2NK5arrus3ops4us4r12TxRxSequence11getTgcCurveEv"></span><span id="arrus::ops::us4r::TxRxSequence::getTgcCurveC"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1TxRxSequence_1a0913c971102b4f9050d5bee5683931da"></span><em class="property">inline</em> <em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrus3ops4us4r8TGCCurveE" title="arrus::ops::us4r::TGCCurve">TGCCurve</a> &amp;<code class="sig-name descname">getTgcCurve</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrus3ops4us4r12TxRxSequence11getTgcCurveEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initial TGC curve points. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus3ops4us4r12TxRxSequence6getSriEv">
<span id="_CPPv3NK5arrus3ops4us4r12TxRxSequence6getSriEv"></span><span id="_CPPv2NK5arrus3ops4us4r12TxRxSequence6getSriEv"></span><span id="arrus::ops::us4r::TxRxSequence::getSriC"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1TxRxSequence_1a4a25ebfa6efc46a95aab9cc96080d9d4"></span><em class="property">inline</em> <em class="property">const</em> std::optional&lt;float&gt; <code class="sig-name descname">getSri</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrus3ops4us4r12TxRxSequence6getSriEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns sequence repetition interval (the total time the given sequence should actually take). nullopt means that the frame acquisition time should be determined by total PRI only. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus3ops4us4r12TxRxSequence12getRxProbeIdEv">
<span id="_CPPv3NK5arrus3ops4us4r12TxRxSequence12getRxProbeIdEv"></span><span id="_CPPv2NK5arrus3ops4us4r12TxRxSequence12getRxProbeIdEv"></span><span id="arrus::ops::us4r::TxRxSequence::getRxProbeIdC"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1TxRxSequence_1a00b3913f4ae3e4bcdd4fc398afb24fbc"></span><em class="property">inline</em> devices::DeviceId <code class="sig-name descname">getRxProbeId</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrus3ops4us4r12TxRxSequence12getRxProbeIdEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the ordinal number of the probe used for RX. If the RX probe is not-unique, this method will throw IllegalStateException. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus3ops4us4r12TxRxSequence12getTxProbeIdEv">
<span id="_CPPv3NK5arrus3ops4us4r12TxRxSequence12getTxProbeIdEv"></span><span id="_CPPv2NK5arrus3ops4us4r12TxRxSequence12getTxProbeIdEv"></span><span id="arrus::ops::us4r::TxRxSequence::getTxProbeIdC"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1TxRxSequence_1aab453726719447374e9c673a9d83af80"></span><em class="property">inline</em> devices::DeviceId <code class="sig-name descname">getTxProbeId</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrus3ops4us4r12TxRxSequence12getTxProbeIdEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the ordinal number of the probe used for RX. If the RX probe is not-unique, this method will throw IllegalStateException. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus3ops4us4r12TxRxSequence4sizeEv">
<span id="_CPPv3NK5arrus3ops4us4r12TxRxSequence4sizeEv"></span><span id="_CPPv2NK5arrus3ops4us4r12TxRxSequence4sizeEv"></span><span id="arrus::ops::us4r::TxRxSequence::sizeC"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1TxRxSequence_1a3b369b9deeb26f4f5154e7411977573e"></span><em class="property">inline</em> size_t <code class="sig-name descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrus3ops4us4r12TxRxSequence4sizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of ops in the given TX/RX sequence. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus3ops4us4r12TxRxSequence7getNameEv">
<span id="_CPPv3NK5arrus3ops4us4r12TxRxSequence7getNameEv"></span><span id="_CPPv2NK5arrus3ops4us4r12TxRxSequence7getNameEv"></span><span id="arrus::ops::us4r::TxRxSequence::getNameC"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1TxRxSequence_1a4accb25d9e264ae3f61939b1bcd94997"></span><em class="property">inline</em> <em class="property">const</em> std::string &amp;<code class="sig-name descname">getName</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrus3ops4us4r12TxRxSequence7getNameEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the name of sequence. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrus3ops4us4r5PulseE">
<span id="_CPPv3N5arrus3ops4us4r5PulseE"></span><span id="_CPPv2N5arrus3ops4us4r5PulseE"></span><span id="arrus::ops::us4r::Pulse"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1Pulse"></span><em class="property">class </em><code class="sig-prename descclassname">arrus::ops::us4r<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">Pulse</code><a class="headerlink" href="#_CPPv4N5arrus3ops4us4r5PulseE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A single pulse (sine wave) produced by us4r device.</p>
<p>DEPRECATED: please use the <a class="reference internal" href="#classarrus_1_1ops_1_1us4r_1_1Waveform"><span class="std std-ref">arrus::ops::us4r::Waveform</span></a> </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrus3ops4us4r5Pulse5PulseEffb14AmplitudeLevel">
<span id="_CPPv3N5arrus3ops4us4r5Pulse5PulseEffb14AmplitudeLevel"></span><span id="_CPPv2N5arrus3ops4us4r5Pulse5PulseEffb14AmplitudeLevel"></span><span id="arrus::ops::us4r::Pulse::Pulse__float.float.b.AmplitudeLevel"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1Pulse_1ad8e961b68fd673e096b4f5818a7cc813"></span><em class="property">inline</em> <code class="sig-name descname">Pulse</code><span class="sig-paren">(</span>float <em>centerFrequency</em>, float <em>nPeriods</em>, bool <em>inverse</em>, AmplitudeLevel <em>amplitudeLevel</em> = 2<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrus3ops4us4r5Pulse5PulseEffb14AmplitudeLevel" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#classarrus_1_1ops_1_1us4r_1_1Pulse"><span class="std std-ref">Pulse</span></a> constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>centerFrequency</strong> – center frequency of the transmitted pulse </p></li>
<li><p><strong>nPeriods</strong> – pulse number of periods, should be a multiple of 0.5 </p></li>
<li><p><strong>inverse</strong> – if set to true - inverse the pulse polarity </p></li>
<li><p><strong>amplitudeLevel</strong> – amplitude level to use, default: 2 (HVM/P 0) </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus3ops4us4r5Pulse14getPulseLengthEv">
<span id="_CPPv3NK5arrus3ops4us4r5Pulse14getPulseLengthEv"></span><span id="_CPPv2NK5arrus3ops4us4r5Pulse14getPulseLengthEv"></span><span id="arrus::ops::us4r::Pulse::getPulseLengthC"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1Pulse_1ac8d13333b9caa33cce29829a9cb27ccf"></span><em class="property">inline</em> float <code class="sig-name descname">getPulseLength</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrus3ops4us4r5Pulse14getPulseLengthEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns pulse duration [s]. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-static-functions">Public Static Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrus3ops4us4r5Pulse12fromWaveformERK8Waveform">
<span id="_CPPv3N5arrus3ops4us4r5Pulse12fromWaveformERK8Waveform"></span><span id="_CPPv2N5arrus3ops4us4r5Pulse12fromWaveformERK8Waveform"></span><span id="arrus::ops::us4r::Pulse::fromWaveform__WaveformCR"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1Pulse_1a790495747ce4f6ba9ecd270e17544d63"></span><em class="property">static</em> <em class="property">inline</em> std::optional&lt;<a class="reference internal" href="#_CPPv4N5arrus3ops4us4r5PulseE" title="arrus::ops::us4r::Pulse">Pulse</a>&gt; <code class="sig-name descname">fromWaveform</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrus3ops4us4r8WaveformE" title="arrus::ops::us4r::Waveform">Waveform</a> &amp;<em>waveform</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrus3ops4us4r5Pulse12fromWaveformERK8Waveform" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Converts the input waveform to a pulse. The conversion is possible only when the structure of the waveform is conformant with the output of the toWaveform method &amp;#8212; the nullopt is returned otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>pulse recovered from the input waveform or std::nullopt, if it was not possible to convert the waveform to the <a class="reference internal" href="#classarrus_1_1ops_1_1us4r_1_1Pulse"><span class="std std-ref">Pulse</span></a> object </p>
</dd>
</dl>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrus3ops4us4r4TxRxE">
<span id="_CPPv3N5arrus3ops4us4r4TxRxE"></span><span id="_CPPv2N5arrus3ops4us4r4TxRxE"></span><span id="arrus::ops::us4r::TxRx"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1TxRx"></span><em class="property">class </em><code class="sig-prename descclassname">arrus::ops::us4r<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">TxRx</code><a class="headerlink" href="#_CPPv4N5arrus3ops4us4r4TxRxE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A single tx/rx operation to perform. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrus3ops4us4r4TxRx4TxRxE2Tx2Rxf">
<span id="_CPPv3N5arrus3ops4us4r4TxRx4TxRxE2Tx2Rxf"></span><span id="_CPPv2N5arrus3ops4us4r4TxRx4TxRxE2Tx2Rxf"></span><span id="arrus::ops::us4r::TxRx::TxRx__Tx.Rx.float"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1TxRx_1ad2730e8e3a7c22042a460068a50bec53"></span><em class="property">inline</em> <code class="sig-name descname">TxRx</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N5arrus3ops4us4r2TxE" title="arrus::ops::us4r::Tx">Tx</a> <em>tx</em>, <a class="reference internal" href="#_CPPv4N5arrus3ops4us4r2RxE" title="arrus::ops::us4r::Rx">Rx</a> <em>rx</em>, float <em>pri</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrus3ops4us4r4TxRx4TxRxE2Tx2Rxf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#classarrus_1_1ops_1_1us4r_1_1TxRx"><span class="std std-ref">TxRx</span></a> constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tx</strong> – - tx description </p></li>
<li><p><strong>rx</strong> – - rx description </p></li>
<li><p><strong>pri</strong> – - pulse repetition interval </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrus3ops4us4r2TxE">
<span id="_CPPv3N5arrus3ops4us4r2TxE"></span><span id="_CPPv2N5arrus3ops4us4r2TxE"></span><span id="arrus::ops::us4r::Tx"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1Tx"></span><em class="property">class </em><code class="sig-prename descclassname">arrus::ops::us4r<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">Tx</code><a class="headerlink" href="#_CPPv4N5arrus3ops4us4r2TxE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A single pulse transmission. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrus3ops4us4r2Tx2TxENSt6vectorIbEENSt6vectorIfEERK5PulseN7devices8DeviceIdE">
<span id="_CPPv3N5arrus3ops4us4r2Tx2TxENSt6vectorIbEENSt6vectorIfEERK5PulseN7devices8DeviceIdE"></span><span id="_CPPv2N5arrus3ops4us4r2Tx2TxENSt6vectorIbEENSt6vectorIfEERK5PulseN7devices8DeviceIdE"></span><span id="arrus::ops::us4r::Tx::Tx__std::vector:b:.std::vector:float:.PulseCR.devices::DeviceId"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1Tx_1af6eff9e0d6d245b4fa4c26f4a9f77de2"></span><em class="property">inline</em> <code class="sig-name descname">Tx</code><span class="sig-paren">(</span>std::vector&lt;bool&gt; <em>aperture</em>, std::vector&lt;float&gt; <em>delays</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrus3ops4us4r5PulseE" title="arrus::ops::us4r::Pulse">Pulse</a> &amp;<em>pulse</em>, devices::DeviceId <em>placement</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrus3ops4us4r2Tx2TxENSt6vectorIbEENSt6vectorIfEERK5PulseN7devices8DeviceIdE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#classarrus_1_1ops_1_1us4r_1_1Tx"><span class="std std-ref">Tx</span></a> constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>aperture</strong> – transmit aperture specified as a bit mask; aperture[i] means that the i-th channel should be turned on </p></li>
<li><p><strong>delays</strong> – transmit delays to apply; delays[i] applies to channel i </p></li>
<li><p><strong>pulse</strong> – pulse to transmit &#64;parma placement probe on which the <a class="reference internal" href="#classarrus_1_1ops_1_1us4r_1_1Tx"><span class="std std-ref">Tx</span></a> should be performed </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus3ops4us4r2Tx21getDelaysApertureOnlyEv">
<span id="_CPPv3NK5arrus3ops4us4r2Tx21getDelaysApertureOnlyEv"></span><span id="_CPPv2NK5arrus3ops4us4r2Tx21getDelaysApertureOnlyEv"></span><span id="arrus::ops::us4r::Tx::getDelaysApertureOnlyC"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1Tx_1acd0b0085378604e7855098efb6a87a54"></span><em class="property">inline</em> std::vector&lt;float&gt; <code class="sig-name descname">getDelaysApertureOnly</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrus3ops4us4r2Tx21getDelaysApertureOnlyEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns an array with delays for active (i.e. aperture[i] = true) channels only. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I0ENK5arrus3ops4us4r2Tx19limitToApertureOnlyENSt6vectorIfEERKNSt6vectorI1TEE">
<span id="_CPPv3I0ENK5arrus3ops4us4r2Tx19limitToApertureOnlyERKNSt6vectorI1TEE"></span><span id="_CPPv2I0ENK5arrus3ops4us4r2Tx19limitToApertureOnlyERKNSt6vectorI1TEE"></span>template&lt;typename <code class="sig-name descname">T</code>&gt;<br /><span class="target" id="classarrus_1_1ops_1_1us4r_1_1Tx_1a8329dcc822e5998d6e3975f6471835ae"></span><em class="property">inline</em> std::vector&lt;float&gt; <code class="sig-name descname">limitToApertureOnly</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;<a class="reference internal" href="#_CPPv4I0ENK5arrus3ops4us4r2Tx19limitToApertureOnlyENSt6vectorIfEERKNSt6vectorI1TEE" title="arrus::ops::us4r::Tx::limitToApertureOnly::T">T</a>&gt; &amp;<em>values</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4I0ENK5arrus3ops4us4r2Tx19limitToApertureOnlyENSt6vectorIfEERKNSt6vectorI1TEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns an array with delays for active (i.e. aperture[i] = true) channels only. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus3ops4us4r2Tx5isNOPEv">
<span id="_CPPv3NK5arrus3ops4us4r2Tx5isNOPEv"></span><span id="_CPPv2NK5arrus3ops4us4r2Tx5isNOPEv"></span><span id="arrus::ops::us4r::Tx::isNOPC"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1Tx_1accc2b2c9588453f53043bd8ac28b40ca"></span><em class="property">inline</em> bool <code class="sig-name descname">isNOP</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrus3ops4us4r2Tx5isNOPEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if this operator does not perform TX at all (i.e. aperture is set to false). </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrus3ops4us4r2RxE">
<span id="_CPPv3N5arrus3ops4us4r2RxE"></span><span id="_CPPv2N5arrus3ops4us4r2RxE"></span><span id="arrus::ops::us4r::Rx"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1Rx"></span><em class="property">class </em><code class="sig-prename descclassname">arrus::ops::us4r<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">Rx</code><a class="headerlink" href="#_CPPv4N5arrus3ops4us4r2RxE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>An operation that performs a single data reception (<a class="reference internal" href="#classarrus_1_1ops_1_1us4r_1_1Rx"><span class="std std-ref">Rx</span></a>). </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrus3ops4us4r2Rx2RxENSt6vectorIbEENSt4pairIjjEEjNSt4pairIttEEN7devices8DeviceIdE">
<span id="_CPPv3N5arrus3ops4us4r2Rx2RxENSt6vectorIbEENSt4pairIjjEEjNSt4pairIttEEN7devices8DeviceIdE"></span><span id="_CPPv2N5arrus3ops4us4r2Rx2RxENSt6vectorIbEENSt4pairIjjEEjNSt4pairIttEEN7devices8DeviceIdE"></span><span id="arrus::ops::us4r::Rx::Rx__std::vector:b:.std::pair:unsigned-i.unsigned-i:.unsigned-i.std::pair:unsigned-short.unsigned-short:.devices::DeviceId"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1Rx_1a7c715a550fff27ea1b7e1fe71089f7f0"></span><em class="property">inline</em> <code class="sig-name descname">Rx</code><span class="sig-paren">(</span>std::vector&lt;bool&gt; <em>aperture</em>, std::pair&lt;unsigned int, unsigned int&gt; <em>sampleRange</em>, unsigned int <em>downsamplingFactor</em> = 1, std::pair&lt;unsigned short, unsigned short&gt; <em>padding</em> = {(ChannelIdx)0, (ChannelIdx)0}, devices::DeviceId <em>placement</em> = devices::DeviceId(devices::DeviceType::Probe, 0)<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrus3ops4us4r2Rx2RxENSt6vectorIbEENSt4pairIjjEEjNSt4pairIttEEN7devices8DeviceIdE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#classarrus_1_1ops_1_1us4r_1_1Rx"><span class="std std-ref">Rx</span></a> constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>aperture</strong> – receive aperture to use; aperture[i] = true means that the i-th channel should be turned on </p></li>
<li><p><strong>rxSampleRange</strong> – [start, end) range of samples to acquire, starts from 0 </p></li>
<li><p><strong>downsamplingFactor</strong> – the factor by which the sampling frequency should be divided, an integer </p></li>
<li><p><strong>placement</strong> – probe on which the RX should be performed. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt>
<span class="target" id="classarrus_1_1ops_1_1us4r_1_1TxRxSequence"></span><em class="property">class </em><code class="sig-prename descclassname">arrus::ops::us4r<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">TxRxSequence</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt>
<span class="target" id="classarrus_1_1ops_1_1us4r_1_1TxRxSequence_1aff75cef686f5244024012ed65874307e"></span><em class="property">inline</em> <code class="sig-name descname">TxRxSequence</code><span class="sig-paren">(</span>std::vector&lt;<a class="reference internal" href="#_CPPv4N5arrus3ops4us4r4TxRxE" title="arrus::ops::us4r::TxRx">TxRx</a>&gt; <em>sequence</em>, <a class="reference internal" href="#_CPPv4N5arrus3ops4us4r8TGCCurveE" title="arrus::ops::us4r::TGCCurve">TGCCurve</a> <em>tgcCurve</em>, float <em>sri</em> = NO_SRI, int16 <em>nRepeats</em> = 1, std::string <em>name</em> = &quot;&quot;<span class="sig-paren">)</span><br /></dt>
<dd><p>Tx/Rx sequence to execute on Us4R device.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sequence</strong> – a list of tx/rxs that compose a given sequence </p></li>
<li><p><strong>tgcCurve</strong> – tgc curve to apply </p></li>
<li><p><strong>sri</strong> – sequence repetition interval - the total time that a given sequence should take. </p></li>
<li><p><strong>nRepeats</strong> – - the number of repetitions of a given sequence. Determines the size of the batch </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt>
<span class="target" id="classarrus_1_1ops_1_1us4r_1_1TxRxSequence_1a5966998860191e9bd458d5d11aa5871b"></span><em class="property">inline</em> <em class="property">const</em> std::vector&lt;<a class="reference internal" href="#_CPPv4N5arrus3ops4us4r4TxRxE" title="arrus::ops::us4r::TxRx">TxRx</a>&gt; &amp;<code class="sig-name descname">getOps</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>Returns vector of operations to perform. </p>
</dd></dl>

<dl class="cpp function">
<dt>
<span class="target" id="classarrus_1_1ops_1_1us4r_1_1TxRxSequence_1a0913c971102b4f9050d5bee5683931da"></span><em class="property">inline</em> <em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrus3ops4us4r8TGCCurveE" title="arrus::ops::us4r::TGCCurve">TGCCurve</a> &amp;<code class="sig-name descname">getTgcCurve</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>Initial TGC curve points. </p>
</dd></dl>

<dl class="cpp function">
<dt>
<span class="target" id="classarrus_1_1ops_1_1us4r_1_1TxRxSequence_1a4a25ebfa6efc46a95aab9cc96080d9d4"></span><em class="property">inline</em> <em class="property">const</em> std::optional&lt;float&gt; <code class="sig-name descname">getSri</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>Returns sequence repetition interval (the total time the given sequence should actually take). nullopt means that the frame acquisition time should be determined by total PRI only. </p>
</dd></dl>

<dl class="cpp function">
<dt>
<span class="target" id="classarrus_1_1ops_1_1us4r_1_1TxRxSequence_1a00b3913f4ae3e4bcdd4fc398afb24fbc"></span><em class="property">inline</em> devices::DeviceId <code class="sig-name descname">getRxProbeId</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>Returns the ordinal number of the probe used for RX. If the RX probe is not-unique, this method will throw IllegalStateException. </p>
</dd></dl>

<dl class="cpp function">
<dt>
<span class="target" id="classarrus_1_1ops_1_1us4r_1_1TxRxSequence_1aab453726719447374e9c673a9d83af80"></span><em class="property">inline</em> devices::DeviceId <code class="sig-name descname">getTxProbeId</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>Returns the ordinal number of the probe used for RX. If the RX probe is not-unique, this method will throw IllegalStateException. </p>
</dd></dl>

<dl class="cpp function">
<dt>
<span class="target" id="classarrus_1_1ops_1_1us4r_1_1TxRxSequence_1a3b369b9deeb26f4f5154e7411977573e"></span><em class="property">inline</em> size_t <code class="sig-name descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>Returns the number of ops in the given TX/RX sequence. </p>
</dd></dl>

<dl class="cpp function">
<dt>
<span class="target" id="classarrus_1_1ops_1_1us4r_1_1TxRxSequence_1a4accb25d9e264ae3f61939b1bcd94997"></span><em class="property">inline</em> <em class="property">const</em> std::string &amp;<code class="sig-name descname">getName</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>Returns the name of sequence. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrus3ops4us4r21DigitalDownConversionE">
<span id="_CPPv3N5arrus3ops4us4r21DigitalDownConversionE"></span><span id="_CPPv2N5arrus3ops4us4r21DigitalDownConversionE"></span><span id="arrus::ops::us4r::DigitalDownConversion"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1DigitalDownConversion"></span><em class="property">class </em><code class="sig-prename descclassname">arrus::ops::us4r<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">DigitalDownConversion</code><a class="headerlink" href="#_CPPv4N5arrus3ops4us4r21DigitalDownConversionE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrus3ops4us4r21DigitalDownConversion21DigitalDownConversionEfNSt6vectorIfEEff">
<span id="_CPPv3N5arrus3ops4us4r21DigitalDownConversion21DigitalDownConversionEfNSt6vectorIfEEff"></span><span id="_CPPv2N5arrus3ops4us4r21DigitalDownConversion21DigitalDownConversionEfNSt6vectorIfEEff"></span><span id="arrus::ops::us4r::DigitalDownConversion::DigitalDownConversion__float.std::vector:float:.float.float"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1DigitalDownConversion_1a5b45800eb371b6962d74465bace7d78c"></span><em class="property">inline</em> <code class="sig-name descname">DigitalDownConversion</code><span class="sig-paren">(</span>float <em>demodulationFrequency</em>, std::vector&lt;float&gt; <em>firCoefficients</em>, float <em>decimationFactor</em>, float <em>gain</em> = 12.0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrus3ops4us4r21DigitalDownConversion21DigitalDownConversionEfNSt6vectorIfEEff" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Us4R Digital Down Conversion block.</p>
<p>Note: the decimation factor can also have a fractional part: 0.25, 0.5 or 0.75.</p>
<p>Note: the FIR filter order (i.e. total number of taps)depends on the decimation factor and should be equal: decimationFactor*16 for integer decimation factor; decimationFactor*32 for decimation factor with fractional part 0.5; decimationFactor*64 for decimation facator with fractional part 0.25 or 0.75.</p>
<p>Note: only a upper half of the FIR filter coefficients should be provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>demodulationFrequency</strong> – demodulation frequency to apply [Hz] </p></li>
<li><p><strong>firCoefficients</strong> – FIR filter coefficients to apply </p></li>
<li><p><strong>decimationFactor</strong> – decimation factor to apply, should be in range [2, 63] </p></li>
<li><p><strong>gain</strong> – an extra digital gain to apply (after decimation filter), by default set to 12 dB. Currently only 0 and 12 dB are supported [dB] </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus3ops4us4r21DigitalDownConversion7getGainEv">
<span id="_CPPv3NK5arrus3ops4us4r21DigitalDownConversion7getGainEv"></span><span id="_CPPv2NK5arrus3ops4us4r21DigitalDownConversion7getGainEv"></span><span id="arrus::ops::us4r::DigitalDownConversion::getGainC"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1DigitalDownConversion_1ad7676cde34dd1814a378a3f2f4f750d3"></span>float <code class="sig-name descname">getGain</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrus3ops4us4r21DigitalDownConversion7getGainEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns an extra digital gain to apply (after the decimation filter). </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N5arrus3ops4us4r8TGCCurveE">
<span id="_CPPv3N5arrus3ops4us4r8TGCCurveE"></span><span id="_CPPv2N5arrus3ops4us4r8TGCCurveE"></span><span class="target" id="tgc_8h_1addb36278331efa0aef7c74e840d7505b"></span><em class="property">using </em><code class="sig-prename descclassname">arrus::ops::us4r<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">TGCCurve</code> = std::vector&lt;TGCSampleValue&gt;<a class="headerlink" href="#_CPPv4N5arrus3ops4us4r8TGCCurveE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>TGC curve to apply on the us4r device. </p>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrus3ops4us4r8WaveformE">
<span id="_CPPv3N5arrus3ops4us4r8WaveformE"></span><span id="_CPPv2N5arrus3ops4us4r8WaveformE"></span><span id="arrus::ops::us4r::Waveform"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1Waveform"></span><em class="property">class </em><code class="sig-name descname">Waveform</code><a class="headerlink" href="#_CPPv4N5arrus3ops4us4r8WaveformE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A complete <a class="reference internal" href="#classarrus_1_1ops_1_1us4r_1_1Tx"><span class="std std-ref">Tx</span></a> waveform to be applied on the ultrasound pulsers.</p>
<p>NOTE: please use <a class="reference internal" href="#classarrus_1_1ops_1_1us4r_1_1WaveformBuilder"><span class="std std-ref">WaveformBuilder</span></a> class to create new TX Waveforms (avoid constructing objects of this class directly).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>segments</strong> – subsequent segments of the waveform </p></li>
<li><p><strong>nRepetitions</strong> – how many times the segments[i] should be repeated </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrus3ops4us4r15WaveformSegmentE">
<span id="_CPPv3N5arrus3ops4us4r15WaveformSegmentE"></span><span id="_CPPv2N5arrus3ops4us4r15WaveformSegmentE"></span><span id="arrus::ops::us4r::WaveformSegment"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1WaveformSegment"></span><em class="property">class </em><code class="sig-name descname">WaveformSegment</code><a class="headerlink" href="#_CPPv4N5arrus3ops4us4r15WaveformSegmentE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Us4R TX waveform segment.</p>
<p><a class="reference internal" href="#classarrus_1_1ops_1_1us4r_1_1WaveformSegment"><span class="std std-ref">WaveformSegment</span></a> is a part of the TX waveform, that can be repated multiple times.</p>
<p>The duration[i] is the duration of the i-th state, i.e. state[i].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> – the sequence of of states, one of the following values: -2 (HVM0), -1 (HVM1), 0 (CLAMP), 1 (HVP1), 2 (HVP0) </p></li>
<li><p><strong>duration</strong> – the duration of the i-th state [seconds] </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrus3ops4us4r15WaveformBuilderE">
<span id="_CPPv3N5arrus3ops4us4r15WaveformBuilderE"></span><span id="_CPPv2N5arrus3ops4us4r15WaveformBuilderE"></span><span id="arrus::ops::us4r::WaveformBuilder"></span><span class="target" id="classarrus_1_1ops_1_1us4r_1_1WaveformBuilder"></span><em class="property">class </em><code class="sig-name descname">WaveformBuilder</code><a class="headerlink" href="#_CPPv4N5arrus3ops4us4r15WaveformBuilderE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#classarrus_1_1ops_1_1us4r_1_1Tx"><span class="std std-ref">Tx</span></a> <a class="reference internal" href="#classarrus_1_1ops_1_1us4r_1_1Waveform"><span class="std std-ref">Waveform</span></a> builder class. </p>
</dd></dl>

</div>
</div>
<div class="section" id="devices">
<h2>Devices<a class="headerlink" href="#devices" title="Permalink to this headline">¶</a></h2>
<dl class="cpp class">
<dt id="_CPPv4N5arrus7devices4Us4RE">
<span id="_CPPv3N5arrus7devices4Us4RE"></span><span id="_CPPv2N5arrus7devices4Us4RE"></span><span id="arrus::devices::Us4R"></span><span class="target" id="classarrus_1_1devices_1_1Us4R"></span><em class="property">class </em><code class="sig-prename descclassname">arrus::devices<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">Us4R</code> : <em class="property">public</em> arrus::devices::Ultrasound, <em class="property">public</em> arrus::devices::DeviceWithComponents<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4RE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#classarrus_1_1devices_1_1Us4R"><span class="std std-ref">Us4R</span></a> system: a group of <a class="reference internal" href="#classarrus_1_1devices_1_1Us4OEM"><span class="std std-ref">Us4OEM</span></a> modules and related components.</p>
<p>By default system starts with IQ demodulator turned off. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R9getUs4OEME7Ordinal">
<span id="_CPPv3N5arrus7devices4Us4R9getUs4OEME7Ordinal"></span><span id="_CPPv2N5arrus7devices4Us4R9getUs4OEME7Ordinal"></span><span id="arrus::devices::Us4R::getUs4OEM__Ordinal"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1ad30c23f56bcfe01978a2c5c5f1606771"></span><em class="property">virtual</em> <a class="reference internal" href="#_CPPv4N5arrus7devices6Us4OEME" title="arrus::devices::Us4OEM">Us4OEM</a> *<code class="sig-name descname">getUs4OEM</code><span class="sig-paren">(</span>Ordinal <em>ordinal</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R9getUs4OEME7Ordinal" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a handle to <a class="reference internal" href="#classarrus_1_1devices_1_1Us4OEM"><span class="std std-ref">Us4OEM</span></a> identified by given ordinal number.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ordinal</strong> – ordinal number of the us4oem to get </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a handle to the us4oem module </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R10setVoltageEh">
<span id="_CPPv3N5arrus7devices4Us4R10setVoltageEh"></span><span id="_CPPv2N5arrus7devices4Us4R10setVoltageEh"></span><span id="arrus::devices::Us4R::setVoltage__unsigned-c"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a59b89b5c748ee7b1b9e86d92d3443081"></span><em class="property">virtual</em> void <code class="sig-name descname">setVoltage</code><span class="sig-paren">(</span>unsigned char <em>voltage</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R10setVoltageEh" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets HV voltage.</p>
<p>The voltage is set for the TX amplitude 2 (rail 0).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>voltage</strong> – voltage to set [V] </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R10setVoltageERKNSt6vectorI9HVVoltageEE">
<span id="_CPPv3N5arrus7devices4Us4R10setVoltageERKNSt6vectorI9HVVoltageEE"></span><span id="_CPPv2N5arrus7devices4Us4R10setVoltageERKNSt6vectorI9HVVoltageEE"></span><span id="arrus::devices::Us4R::setVoltage__std::vector:HVVoltage:CR"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a5c337630f31c608c1529226f3688657c"></span><em class="property">virtual</em> void <code class="sig-name descname">setVoltage</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;<a class="reference internal" href="#_CPPv4N5arrus7devices9HVVoltageE" title="arrus::devices::HVVoltage">HVVoltage</a>&gt; &amp;<em>voltages</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R10setVoltageERKNSt6vectorI9HVVoltageEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets HV voltage. The input vector describes what voltages should be set for each tx voltage level (rail).</p>
<p>voltages[0] are for the TX amplitude/state 1 (-/+), voltage[1] are for TX amplitude/state level 2 and so on.</p>
<p>For the legacy systems (using e.g. the legacy HV256 or us4rPSC) this method expects a list of voltages {0, -/+ voltage}.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>voltages</strong> – voltages to set [V] </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R10getVoltageEv">
<span id="_CPPv3N5arrus7devices4Us4R10getVoltageEv"></span><span id="_CPPv2N5arrus7devices4Us4R10getVoltageEv"></span><span id="arrus::devices::Us4R::getVoltage"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a6250f0561d1a9a58c0b44470869b07e4"></span><em class="property">virtual</em> unsigned char <code class="sig-name descname">getVoltage</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R10getVoltageEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns configured HV voltage.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>hv voltage value configured on device [V] </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R19getMeasuredPVoltageEv">
<span id="_CPPv3N5arrus7devices4Us4R19getMeasuredPVoltageEv"></span><span id="_CPPv2N5arrus7devices4Us4R19getMeasuredPVoltageEv"></span><span id="arrus::devices::Us4R::getMeasuredPVoltage"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1acce72f235ab69c9c26b7dac24651f0e2"></span><em class="property">virtual</em> float <code class="sig-name descname">getMeasuredPVoltage</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R19getMeasuredPVoltageEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns measured HV voltage (plus).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>hv voltage measured by device [V] </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R19getMeasuredMVoltageEv">
<span id="_CPPv3N5arrus7devices4Us4R19getMeasuredMVoltageEv"></span><span id="_CPPv2N5arrus7devices4Us4R19getMeasuredMVoltageEv"></span><span id="arrus::devices::Us4R::getMeasuredMVoltage"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a5f631748802e3704d1b1020c03cb0e2a"></span><em class="property">virtual</em> float <code class="sig-name descname">getMeasuredMVoltage</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R19getMeasuredMVoltageEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns measured HV voltage (minus).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>hv voltage measured by devivce [V] </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R21getMeasuredHVPVoltageE7uint8_t">
<span id="_CPPv3N5arrus7devices4Us4R21getMeasuredHVPVoltageE7uint8_t"></span><span id="_CPPv2N5arrus7devices4Us4R21getMeasuredHVPVoltageE7uint8_t"></span><span id="arrus::devices::Us4R::getMeasuredHVPVoltage__uint8_t"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1ae409864c949ef7aefe3f0666648ee3ec"></span><em class="property">virtual</em> float <code class="sig-name descname">getMeasuredHVPVoltage</code><span class="sig-paren">(</span>uint8_t <em>oemId</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R21getMeasuredHVPVoltageE7uint8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Gets positive HV voltage measurement by UCD chip on OEM.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>oemId</strong> – OEM ID </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>positive HV voltage UCD measurement [V] </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R21getMeasuredHVMVoltageE7uint8_t">
<span id="_CPPv3N5arrus7devices4Us4R21getMeasuredHVMVoltageE7uint8_t"></span><span id="_CPPv2N5arrus7devices4Us4R21getMeasuredHVMVoltageE7uint8_t"></span><span id="arrus::devices::Us4R::getMeasuredHVMVoltage__uint8_t"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a301dc0d7f8b2549a60e4b0b521056de8"></span><em class="property">virtual</em> float <code class="sig-name descname">getMeasuredHVMVoltage</code><span class="sig-paren">(</span>uint8_t <em>oemId</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R21getMeasuredHVMVoltageE7uint8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Gets negative HV voltage measurement by UCD chip on OEM.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>oemId</strong> – OEM ID </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>negative HV voltage UCD measurement [V] </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R9disableHVEv">
<span id="_CPPv3N5arrus7devices4Us4R9disableHVEv"></span><span id="_CPPv2N5arrus7devices4Us4R9disableHVEv"></span><span id="arrus::devices::Us4R::disableHV"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a5da41a5f443ad91aad9af92463d235e1"></span><em class="property">virtual</em> void <code class="sig-name descname">disableHV</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R9disableHVEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Disables HV voltage. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R11setTgcCurveERKNSt6vectorIfEE">
<span id="_CPPv3N5arrus7devices4Us4R11setTgcCurveERKNSt6vectorIfEE"></span><span id="_CPPv2N5arrus7devices4Us4R11setTgcCurveERKNSt6vectorIfEE"></span><span id="arrus::devices::Us4R::setTgcCurve__std::vector:float:CR"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1aa525868ff0b1593465bb36a4ff532b08"></span><em class="property">virtual</em> void <code class="sig-name descname">setTgcCurve</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;float&gt; &amp;<em>tgcCurvePoints</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R11setTgcCurveERKNSt6vectorIfEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Equivalent to setTgcCurve(curve, true). </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R11setTgcCurveERKNSt6vectorIfEEbb">
<span id="_CPPv3N5arrus7devices4Us4R11setTgcCurveERKNSt6vectorIfEEbb"></span><span id="_CPPv2N5arrus7devices4Us4R11setTgcCurveERKNSt6vectorIfEEbb"></span><span id="arrus::devices::Us4R::setTgcCurve__std::vector:float:CR.b.b"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a994a170dc1c25580f68ff80b607b08c4"></span><em class="property">virtual</em> void <code class="sig-name descname">setTgcCurve</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;float&gt; &amp;<em>tgcCurvePoints</em>, bool <em>applyCharacteristic</em>, bool <em>clip</em> = false<span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R11setTgcCurveERKNSt6vectorIfEEbb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets TGC curve points asynchronously.</p>
<p>Setting empty vector turns off analog TGC. Setting non-empty vector turns off DTGC and turns on analog TGC.</p>
<p>TGC curve can have up to 1022 samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tgcCurvePoints</strong> – tgc curve points to set (gain [dB]) </p></li>
<li><p><strong>applyCharacteristic</strong> – set it to true if you want to compensate response characteristic (pre-computed by us4us). If true, LNA and PGA gains should be set to 24 an 30 dB, respectively, otherwise an arrus::IllegalArgumentException will be thrown. </p></li>
<li><p><strong>clip</strong> – set it true if you would like to get TGC clipped to the min/max possible gain value; otherwise, an IllegalArgumentException will be raised with message that the maximum possible gain value (resulting from amplifier settings such as LNA and PGA) is exceeded. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R11setTgcCurveERKNSt6vectorIfEERKNSt6vectorIfEEbb">
<span id="_CPPv3N5arrus7devices4Us4R11setTgcCurveERKNSt6vectorIfEERKNSt6vectorIfEEbb"></span><span id="_CPPv2N5arrus7devices4Us4R11setTgcCurveERKNSt6vectorIfEERKNSt6vectorIfEEbb"></span><span id="arrus::devices::Us4R::setTgcCurve__std::vector:float:CR.std::vector:float:CR.b.b"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1acf58caacea6630fc1ebc91734ddb5675"></span><em class="property">virtual</em> void <code class="sig-name descname">setTgcCurve</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;float&gt; &amp;<em>t</em>, <em class="property">const</em> std::vector&lt;float&gt; &amp;<em>y</em>, bool <em>applyCharacteristic</em>, bool <em>clip</em> = false<span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R11setTgcCurveERKNSt6vectorIfEERKNSt6vectorIfEEbb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets TGC curve points asynchronously.</p>
<p>Setting empty vectors t and y turns off analog TGC. Setting non-empty vector turns off DTGC and turns on analog TGC.</p>
<p>Vectors t and y should have exactly the same size. The input t and y values will be interpolated into target hardware sampling points (according to getCurrentSamplingFrequency and getCurrentTgcPoints). Linear interpolation will be performed, the TGC curve will be extrapolated with the first (left-side of the cure) and the last sample (right side of the curve).</p>
<p>NOTE: TGC curve can have up to 1022 samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> – sampling time, relative to the “sample 0” </p></li>
<li><p><strong>y</strong> – gain values to apply at given sampling time [dB] </p></li>
<li><p><strong>applyCharacteristic</strong> – set it to true if you want to compensate response characteristic (pre-computed by us4us). If true, LNA and PGA gains should be set to 24 an 30 dB, respectively, otherwise an arrus::IllegalArgumentException will be thrown. </p></li>
<li><p><strong>clip</strong> – set it true if you would like to get TGC clipped to the min/max possible gain value; otherwise, an IllegalArgumentException will be raised with message that the maximum possible gain value (resulting from amplifier settings such as LNA and PGA) is exceeded. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus7devices4Us4R17getTgcCurvePointsEf">
<span id="_CPPv3NK5arrus7devices4Us4R17getTgcCurvePointsEf"></span><span id="_CPPv2NK5arrus7devices4Us4R17getTgcCurvePointsEf"></span><span id="arrus::devices::Us4R::getTgcCurvePoints__floatC"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a9eade261861d4e6f6b2d7f841b461a10"></span><em class="property">virtual</em> std::vector&lt;float&gt; <code class="sig-name descname">getTgcCurvePoints</code><span class="sig-paren">(</span>float <em>maxT</em><span class="sig-paren">)</span> <em class="property">const</em> = 0<a class="headerlink" href="#_CPPv4NK5arrus7devices4Us4R17getTgcCurvePointsEf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns us4R TGC sampling points (along time axis, relative to the “sample 0”), up to given maximum time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>maxT</strong> – maximum time range </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>TGC time points at which TGC curve sample takes place </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R7setVcatERKNSt6vectorIfEERKNSt6vectorIfEEbb">
<span id="_CPPv3N5arrus7devices4Us4R7setVcatERKNSt6vectorIfEERKNSt6vectorIfEEbb"></span><span id="_CPPv2N5arrus7devices4Us4R7setVcatERKNSt6vectorIfEERKNSt6vectorIfEEbb"></span><span id="arrus::devices::Us4R::setVcat__std::vector:float:CR.std::vector:float:CR.b.b"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a23612135fec391e8f593e8f9dc702c6d"></span><em class="property">virtual</em> void <code class="sig-name descname">setVcat</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;float&gt; &amp;<em>t</em>, <em class="property">const</em> std::vector&lt;float&gt; &amp;<em>y</em>, bool <em>applyCharacteristic</em>, bool <em>clip</em> = false<span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R7setVcatERKNSt6vectorIfEERKNSt6vectorIfEEbb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets VCAT time points asynchronously.</p>
<p>Setting empty vectors t and y turns off analog TGC. Setting non-empty vector turns off DTGC and turns on analog TGC.</p>
<p>Vectors t and y should have exactly the same size. The input t and y values will be interpolated into target hardware sampling points (according to getCurrentSamplingFrequency and getCurrentTgcPoints). Linear interpolation will be performed, the TGC curve will be extrapolated with the first (left-side of the cure) and the last sample (right side of the curve).</p>
<p>NOTE: the curve can have up to 1022 samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> – sampling time, relative to the “sample 0” </p></li>
<li><p><strong>y</strong> – attenuation values to apply at given sampling time [dB] </p></li>
<li><p><strong>applyCharacteristic</strong> – set it to true if you want to compensate response characteristic (pre-computed by us4us). If true, LNA and PGA gains should be set to 24 an 30 dB, respectively, otherwise an arrus::IllegalArgumentException will be thrown. </p></li>
<li><p><strong>clip</strong> – set it true if you would like to get TGC clipped to the min/max possible gain value; otherwise, an IllegalArgumentException will be raised with message that the maximum possible gain value (resulting from amplifier settings such as LNA and PGA) is exceeded. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R7setVcatERKNSt6vectorIfEE">
<span id="_CPPv3N5arrus7devices4Us4R7setVcatERKNSt6vectorIfEE"></span><span id="_CPPv2N5arrus7devices4Us4R7setVcatERKNSt6vectorIfEE"></span><span id="arrus::devices::Us4R::setVcat__std::vector:float:CR"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a0cb3b617a06818dbab60c0c2e5cdbe76"></span><em class="property">virtual</em> void <code class="sig-name descname">setVcat</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;float&gt; &amp;<em>tgcCurvePoints</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R7setVcatERKNSt6vectorIfEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Equivalent to setVcat(curve, true, false). </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R7setVcatERKNSt6vectorIfEEbb">
<span id="_CPPv3N5arrus7devices4Us4R7setVcatERKNSt6vectorIfEEbb"></span><span id="_CPPv2N5arrus7devices4Us4R7setVcatERKNSt6vectorIfEEbb"></span><span id="arrus::devices::Us4R::setVcat__std::vector:float:CR.b.b"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1af3af7614aa8100db56cbb7986c77aee6"></span><em class="property">virtual</em> void <code class="sig-name descname">setVcat</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;float&gt; &amp;<em>tgcCurvePoints</em>, bool <em>applyCharacteristic</em>, bool <em>clip</em> = false<span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R7setVcatERKNSt6vectorIfEEbb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets VCAT points asynchronously.</p>
<p>Setting empty vector turns off analog TGC. Setting non-empty vector turns off DTGC and turns on analog TGC.</p>
<p>The curve can have up to 1022 samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tgcCurvePoints</strong> – tgc curve points to set (gain [dB]) </p></li>
<li><p><strong>applyCharacteristic</strong> – set it to true if you want to compensate response characteristic (pre-computed by us4us). If true, LNA and PGA gains should be set to 24 an 30 dB, respectively, otherwise an arrus::IllegalArgumentException will be thrown. </p></li>
<li><p><strong>clip</strong> – set it true if you would like to get TGC clipped to the min/max possible gain value; otherwise, an IllegalArgumentException will be raised with message that the maximum possible gain value (resulting from amplifier settings such as LNA and PGA) is exceeded. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R10setPgaGainE6uint16">
<span id="_CPPv3N5arrus7devices4Us4R10setPgaGainE6uint16"></span><span id="_CPPv2N5arrus7devices4Us4R10setPgaGainE6uint16"></span><span id="arrus::devices::Us4R::setPgaGain__uint16"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1ace87f6fb2a29ca456f324e261c1d6d9b"></span><em class="property">virtual</em> void <code class="sig-name descname">setPgaGain</code><span class="sig-paren">(</span>uint16 <em>value</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R10setPgaGainE6uint16" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets PGA gain.</p>
<p>See docs of arrus::devices::RxSettings for more information. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R10getPgaGainEv">
<span id="_CPPv3N5arrus7devices4Us4R10getPgaGainEv"></span><span id="_CPPv2N5arrus7devices4Us4R10getPgaGainEv"></span><span id="arrus::devices::Us4R::getPgaGain"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1ad85dd268e86d8c6471967028a0efc9ec"></span><em class="property">virtual</em> uint16 <code class="sig-name descname">getPgaGain</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R10getPgaGainEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the current PGA gain value.</p>
<p>See docs of arrus::devices::RxSettings for more information. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R10setLnaGainE6uint16">
<span id="_CPPv3N5arrus7devices4Us4R10setLnaGainE6uint16"></span><span id="_CPPv2N5arrus7devices4Us4R10setLnaGainE6uint16"></span><span id="arrus::devices::Us4R::setLnaGain__uint16"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a766ce81bca6f3673fe7f16486396ffad"></span><em class="property">virtual</em> void <code class="sig-name descname">setLnaGain</code><span class="sig-paren">(</span>uint16 <em>value</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R10setLnaGainE6uint16" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets LNA gain.</p>
<p>See docs of arrus::devices::RxSettings for more information. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R10getLnaGainEv">
<span id="_CPPv3N5arrus7devices4Us4R10getLnaGainEv"></span><span id="_CPPv2N5arrus7devices4Us4R10getLnaGainEv"></span><span id="arrus::devices::Us4R::getLnaGain"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a6f896555143b8eb349a47f7b78fba2a2"></span><em class="property">virtual</em> uint16 <code class="sig-name descname">getLnaGain</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R10getLnaGainEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the current LNA gain value.</p>
<p>See docs of arrus::devices::RxSettings for more information. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R12setLpfCutoffE6uint32">
<span id="_CPPv3N5arrus7devices4Us4R12setLpfCutoffE6uint32"></span><span id="_CPPv2N5arrus7devices4Us4R12setLpfCutoffE6uint32"></span><span id="arrus::devices::Us4R::setLpfCutoff__uint32"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1ad2ed90a89c62dfacf12d816b4233fdb6"></span><em class="property">virtual</em> void <code class="sig-name descname">setLpfCutoff</code><span class="sig-paren">(</span>uint32 <em>value</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R12setLpfCutoffE6uint32" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets LPF cutoff.</p>
<p>See docs of arrus::devices::RxSettings for more information. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R18setDtgcAttenuationENSt8optionalI6uint16EE">
<span id="_CPPv3N5arrus7devices4Us4R18setDtgcAttenuationENSt8optionalI6uint16EE"></span><span id="_CPPv2N5arrus7devices4Us4R18setDtgcAttenuationENSt8optionalI6uint16EE"></span><span id="arrus::devices::Us4R::setDtgcAttenuation__std::optional:uint16:"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a3594f3cb1c65409c699c82582c84cbb1"></span><em class="property">virtual</em> void <code class="sig-name descname">setDtgcAttenuation</code><span class="sig-paren">(</span>std::optional&lt;uint16&gt; <em>value</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R18setDtgcAttenuationENSt8optionalI6uint16EE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets DTGC attenuation.</p>
<p>See docs of arrus::devices::RxSettings for more information. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R20setActiveTerminationENSt8optionalI6uint16EE">
<span id="_CPPv3N5arrus7devices4Us4R20setActiveTerminationENSt8optionalI6uint16EE"></span><span id="_CPPv2N5arrus7devices4Us4R20setActiveTerminationENSt8optionalI6uint16EE"></span><span id="arrus::devices::Us4R::setActiveTermination__std::optional:uint16:"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a0b603b39f890939c182b5b933fd876d1"></span><em class="property">virtual</em> void <code class="sig-name descname">setActiveTermination</code><span class="sig-paren">(</span>std::optional&lt;uint16&gt; <em>value</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R20setActiveTerminationENSt8optionalI6uint16EE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets active termination.</p>
<p>See docs of arrus::devices::RxSettings for more information. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R13setRxSettingsERK10RxSettings">
<span id="_CPPv3N5arrus7devices4Us4R13setRxSettingsERK10RxSettings"></span><span id="_CPPv2N5arrus7devices4Us4R13setRxSettingsERK10RxSettings"></span><span id="arrus::devices::Us4R::setRxSettings__RxSettingsCR"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1ae8e62a2fcce825b2ee9f3217c0320ea7"></span><em class="property">virtual</em> void <code class="sig-name descname">setRxSettings</code><span class="sig-paren">(</span><em class="property">const</em> RxSettings &amp;<em>settings</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R13setRxSettingsERK10RxSettings" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets a complete list of RxSettings on all <a class="reference internal" href="#classarrus_1_1devices_1_1Us4R"><span class="std std-ref">Us4R</span></a> components.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>settings</strong> – settings to apply </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R14setTestPatternEN6Us4OEM13RxTestPatternE">
<span id="_CPPv3N5arrus7devices4Us4R14setTestPatternEN6Us4OEM13RxTestPatternE"></span><span id="_CPPv2N5arrus7devices4Us4R14setTestPatternEN6Us4OEM13RxTestPatternE"></span><span id="arrus::devices::Us4R::setTestPattern__Us4OEM::RxTestPattern"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a47e9bb9e36432a0b2f0d934ec7497dc4"></span><em class="property">virtual</em> void <code class="sig-name descname">setTestPattern</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N5arrus7devices6Us4OEME" title="arrus::devices::Us4OEM">Us4OEM</a>::<a class="reference internal" href="#_CPPv4N5arrus7devices6Us4OEM13RxTestPatternE" title="arrus::devices::Us4OEM::RxTestPattern">RxTestPattern</a> <em>pattern</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R14setTestPatternEN6Us4OEM13RxTestPatternE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>If active is true, turns off probe’s RX data acquisition and turns on test patterns generation. Otherwise turns off test patterns generation and turns on probe’s RX data acquisition. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R7triggerEbNSt8optionalIxEE">
<span id="_CPPv3N5arrus7devices4Us4R7triggerEbNSt8optionalIxEE"></span><span id="_CPPv2N5arrus7devices4Us4R7triggerEbNSt8optionalIxEE"></span><span id="arrus::devices::Us4R::trigger__b.std::optional:l-l:"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1ae19ba5a83eef78671a938eae78fb7efa"></span><em class="property">virtual</em> void <code class="sig-name descname">trigger</code><span class="sig-paren">(</span>bool <em>sync</em>, std::optional&lt;long long&gt; <em>timeout</em><span class="sig-paren">)</span> <em class="property">override</em> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R7triggerEbNSt8optionalIxEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Trigger a single run of the current work mode (TX/RX in case of workMode=MANUAL_OP, sequence of TX/RXs in other cases).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sync</strong> – whether this method should work in a synchronous or asynchronous; true means synchronous, i.e. the caller will wait until the triggered TX/RX or sequence of TX/RXs has been done. </p></li>
<li><p><strong>timeout</strong> – timeout [ms]; std::nullopt means to wait infinitely. This parameter is only relevant when sync = true. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R4syncENSt8optionalIxEE">
<span id="_CPPv3N5arrus7devices4Us4R4syncENSt8optionalIxEE"></span><span id="_CPPv2N5arrus7devices4Us4R4syncENSt8optionalIxEE"></span><span id="arrus::devices::Us4R::sync__std::optional:l-l:"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a0bc9c3e3c9ad1238df2833b20b7fe65c"></span><em class="property">virtual</em> void <code class="sig-name descname">sync</code><span class="sig-paren">(</span>std::optional&lt;long long&gt; <em>timeout</em><span class="sig-paren">)</span> <em class="property">override</em> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R4syncENSt8optionalIxEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Synchronization point with us4R system. After returning from this method, the last “TX/RX” (triggered by the trigger method will be fully executed by the system.</p>
<p>Sync with “SEQ_IRQ” interrupt (i.e. wait until the SEQ IRQ will occur).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>timeout</strong> – timeout in number of milliseconds </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R18getNumberOfUs4OEMsEv">
<span id="_CPPv3N5arrus7devices4Us4R18getNumberOfUs4OEMsEv"></span><span id="_CPPv2N5arrus7devices4Us4R18getNumberOfUs4OEMsEv"></span><span id="arrus::devices::Us4R::getNumberOfUs4OEMs"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a57b03a8cf6a1d43a60f3001c46b405f7"></span><em class="property">virtual</em> uint8_t <code class="sig-name descname">getNumberOfUs4OEMs</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R18getNumberOfUs4OEMsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of us4OEM modules that are used in this us4R system. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus7devices4Us4R17getNumberOfProbesEv">
<span id="_CPPv3NK5arrus7devices4Us4R17getNumberOfProbesEv"></span><span id="_CPPv2NK5arrus7devices4Us4R17getNumberOfProbesEv"></span><span id="arrus::devices::Us4R::getNumberOfProbesC"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1afe74d308673954859e3bb6f5e49e4848"></span><em class="property">virtual</em> int <code class="sig-name descname">getNumberOfProbes</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em> = 0<a class="headerlink" href="#_CPPv4NK5arrus7devices4Us4R17getNumberOfProbesEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of probes that are connected to the system. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus7devices4Us4R20getSamplingFrequencyEv">
<span id="_CPPv3NK5arrus7devices4Us4R20getSamplingFrequencyEv"></span><span id="_CPPv2NK5arrus7devices4Us4R20getSamplingFrequencyEv"></span><span id="arrus::devices::Us4R::getSamplingFrequencyC"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1ab95cd11c17471b0f9b9664644b6369c9"></span><em class="property">virtual</em> float <code class="sig-name descname">getSamplingFrequency</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em> = 0<a class="headerlink" href="#_CPPv4NK5arrus7devices4Us4R20getSamplingFrequencyEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns NOMINAL us4R device sampling frequency. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus7devices4Us4R27getCurrentSamplingFrequencyEv">
<span id="_CPPv3NK5arrus7devices4Us4R27getCurrentSamplingFrequencyEv"></span><span id="_CPPv2NK5arrus7devices4Us4R27getCurrentSamplingFrequencyEv"></span><span id="arrus::devices::Us4R::getCurrentSamplingFrequencyC"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a4d5de58ad7a862ceedf7f620dc52b1a5"></span><em class="property">virtual</em> float <code class="sig-name descname">getCurrentSamplingFrequency</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em> = 0<a class="headerlink" href="#_CPPv4NK5arrus7devices4Us4R27getCurrentSamplingFrequencyEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the sampling frequency with which data from us4R will be acquired. The returned value depends on the result of sequence upload (e.g. DDC decimation factor). </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus7devices4Us4R10checkStateEv">
<span id="_CPPv3NK5arrus7devices4Us4R10checkStateEv"></span><span id="_CPPv2NK5arrus7devices4Us4R10checkStateEv"></span><span id="arrus::devices::Us4R::checkStateC"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a6f57d298f009c5beda84a4bd058fed14"></span><em class="property">virtual</em> void <code class="sig-name descname">checkState</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> = 0<a class="headerlink" href="#_CPPv4NK5arrus7devices4Us4R10checkStateEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Checks state of the <a class="reference internal" href="#classarrus_1_1devices_1_1Us4R"><span class="std std-ref">Us4R</span></a> device. Currently checks if each us4OEM module is in the correct state.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>arrus::IllegalStateException</strong> – when some inconsistent state was detected </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R17setStopOnOverflowEb">
<span id="_CPPv3N5arrus7devices4Us4R17setStopOnOverflowEb"></span><span id="_CPPv2N5arrus7devices4Us4R17setStopOnOverflowEb"></span><span id="arrus::devices::Us4R::setStopOnOverflow__b"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a3c3a039a7100f63b11699625994eeb0d"></span><em class="property">virtual</em> void <code class="sig-name descname">setStopOnOverflow</code><span class="sig-paren">(</span>bool <em>isStopOnOverflow</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R17setStopOnOverflowEb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the system to stop when (RX or host) buffer overflow is detected.</p>
<p>This property is set by default to true.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>isStopOnOverflow</strong> – whether the system should stop when buffer overflow is detected. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus7devices4Us4R16isStopOnOverflowEv">
<span id="_CPPv3NK5arrus7devices4Us4R16isStopOnOverflowEv"></span><span id="_CPPv2NK5arrus7devices4Us4R16isStopOnOverflowEv"></span><span id="arrus::devices::Us4R::isStopOnOverflowC"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a62fbd9088012d16bef071f110f21daf8"></span><em class="property">virtual</em> bool <code class="sig-name descname">isStopOnOverflow</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> = 0<a class="headerlink" href="#_CPPv4NK5arrus7devices4Us4R16isStopOnOverflowEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if the system will be stopped when (RX of host) buffer overflow is detected.</p>
<p>This property is set by default to true.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>isStopOnOverflow</strong> – whether the system should stop when buffer overflow is detected. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R24setLnaHpfCornerFrequencyE8uint32_t">
<span id="_CPPv3N5arrus7devices4Us4R24setLnaHpfCornerFrequencyE8uint32_t"></span><span id="_CPPv2N5arrus7devices4Us4R24setLnaHpfCornerFrequencyE8uint32_t"></span><span id="arrus::devices::Us4R::setLnaHpfCornerFrequency__uint32_t"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1acbd64dff811e32e608fa3f0186b3ad4c"></span><em class="property">virtual</em> void <code class="sig-name descname">setLnaHpfCornerFrequency</code><span class="sig-paren">(</span>uint32_t <em>frequency</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R24setLnaHpfCornerFrequencyE8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Enables LNA analog high-pass filter and sets a given corner frequency.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>frequency</strong> – LNA high-pass filter corner frequency to set </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R21setHpfCornerFrequencyE8uint32_t">
<span id="_CPPv3N5arrus7devices4Us4R21setHpfCornerFrequencyE8uint32_t"></span><span id="_CPPv2N5arrus7devices4Us4R21setHpfCornerFrequencyE8uint32_t"></span><span id="arrus::devices::Us4R::setHpfCornerFrequency__uint32_t"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1aebe6ea83e47cf05d51e8ec1e9d70e64c"></span><em class="property">virtual</em> void <code class="sig-name descname">setHpfCornerFrequency</code><span class="sig-paren">(</span>uint32_t <em>frequency</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R21setHpfCornerFrequencyE8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Enables ADC high-pass filter and sets a given corner frequency.</p>
<p>Note: this method is just an alias for setAdcHpfCornerFrequency.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>frequency</strong> – high-pass filter corner frequency to set </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R13disableLnaHpfEv">
<span id="_CPPv3N5arrus7devices4Us4R13disableLnaHpfEv"></span><span id="_CPPv2N5arrus7devices4Us4R13disableLnaHpfEv"></span><span id="arrus::devices::Us4R::disableLnaHpf"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a5b93d8dab9362a502e960a4f5087ef99"></span><em class="property">virtual</em> void <code class="sig-name descname">disableLnaHpf</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R13disableLnaHpfEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Disables LNA analog high-pass filter. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R10disableHpfEv">
<span id="_CPPv3N5arrus7devices4Us4R10disableHpfEv"></span><span id="_CPPv2N5arrus7devices4Us4R10disableHpfEv"></span><span id="arrus::devices::Us4R::disableHpf"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a6305cb1c3ffa1ad92308c82bb174829c"></span><em class="property">virtual</em> void <code class="sig-name descname">disableHpf</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R10disableHpfEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Disables ADC high-pass filter.</p>
<p>Note: this method is just an alias for setAdcHpfCornerFrequency. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R24setAdcHpfCornerFrequencyE8uint32_t">
<span id="_CPPv3N5arrus7devices4Us4R24setAdcHpfCornerFrequencyE8uint32_t"></span><span id="_CPPv2N5arrus7devices4Us4R24setAdcHpfCornerFrequencyE8uint32_t"></span><span id="arrus::devices::Us4R::setAdcHpfCornerFrequency__uint32_t"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1af78f7cda24875b47ce54f819c371c825"></span><em class="property">virtual</em> void <code class="sig-name descname">setAdcHpfCornerFrequency</code><span class="sig-paren">(</span>uint32_t <em>frequency</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R24setAdcHpfCornerFrequencyE8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Enables ADC digital high-pass filter and sets a given corner frequency.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>frequency</strong> – ADC high-pass filter corner frequency to set </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R13disableAdcHpfEv">
<span id="_CPPv3N5arrus7devices4Us4R13disableAdcHpfEv"></span><span id="_CPPv2N5arrus7devices4Us4R13disableAdcHpfEv"></span><span id="arrus::devices::Us4R::disableAdcHpf"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a811ab8a35dbd11eaa7644c8fcb8d10a7"></span><em class="property">virtual</em> void <code class="sig-name descname">disableAdcHpf</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R13disableAdcHpfEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Disables ADC digital high-pass filter. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R6getAfeE7uint8_t">
<span id="_CPPv3N5arrus7devices4Us4R6getAfeE7uint8_t"></span><span id="_CPPv2N5arrus7devices4Us4R6getAfeE7uint8_t"></span><span id="arrus::devices::Us4R::getAfe__uint8_t"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a5b2444d4b5f655ea3f81058e58ab35a8"></span><em class="property">virtual</em> uint16_t <code class="sig-name descname">getAfe</code><span class="sig-paren">(</span>uint8_t <em>reg</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R6getAfeE7uint8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reads AFE register</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>reg</strong> – register address </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R6setAfeE7uint8_t8uint16_t">
<span id="_CPPv3N5arrus7devices4Us4R6setAfeE7uint8_t8uint16_t"></span><span id="_CPPv2N5arrus7devices4Us4R6setAfeE7uint8_t8uint16_t"></span><span id="arrus::devices::Us4R::setAfe__uint8_t.uint16_t"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1ae269d6398e4cf72281dc823e2a0b0942"></span><em class="property">virtual</em> void <code class="sig-name descname">setAfe</code><span class="sig-paren">(</span>uint8_t <em>reg</em>, uint16_t <em>val</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R6setAfeE7uint8_t8uint16_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Writes AFE register</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg</strong> – register address </p></li>
<li><p><strong>val</strong> – register value </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R24getBackplaneSerialNumberEv">
<span id="_CPPv3N5arrus7devices4Us4R24getBackplaneSerialNumberEv"></span><span id="_CPPv2N5arrus7devices4Us4R24getBackplaneSerialNumberEv"></span><span id="arrus::devices::Us4R::getBackplaneSerialNumber"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1aa6d2c991a9d09028cff3090a80be1712"></span><em class="property">virtual</em> <em class="property">const</em> char *<code class="sig-name descname">getBackplaneSerialNumber</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R24getBackplaneSerialNumberEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns serial number of the backplane (if available). </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R20getBackplaneRevisionEv">
<span id="_CPPv3N5arrus7devices4Us4R20getBackplaneRevisionEv"></span><span id="_CPPv2N5arrus7devices4Us4R20getBackplaneRevisionEv"></span><span id="arrus::devices::Us4R::getBackplaneRevision"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a570b0349308a5616d28480ac798a5270"></span><em class="property">virtual</em> <em class="property">const</em> char *<code class="sig-name descname">getBackplaneRevision</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R20getBackplaneRevisionEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns serial number of the backplane (if available). </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R27getBackplaneFirmwareVersionEv">
<span id="_CPPv3N5arrus7devices4Us4R27getBackplaneFirmwareVersionEv"></span><span id="_CPPv2N5arrus7devices4Us4R27getBackplaneFirmwareVersionEv"></span><span id="arrus::devices::Us4R::getBackplaneFirmwareVersion"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a2b13c72225c8f8803b63f940997c15f6"></span><em class="property">virtual</em> <em class="property">const</em> char *<code class="sig-name descname">getBackplaneFirmwareVersion</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R27getBackplaneFirmwareVersionEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns firmware version number of the backplane (if available). </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R15setSubsequencesERKNSt6vectorI5SliceEERKNSt6vectorINSt8optionalIfEEEE">
<span id="_CPPv3N5arrus7devices4Us4R15setSubsequencesERKNSt6vectorI5SliceEERKNSt6vectorINSt8optionalIfEEEE"></span><span id="_CPPv2N5arrus7devices4Us4R15setSubsequencesERKNSt6vectorI5SliceEERKNSt6vectorINSt8optionalIfEEEE"></span><span id="arrus::devices::Us4R::setSubsequences__std::vector:Slice:CR.std::vector:std::optional:float::CR"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a1e0c726fecdd974b0f00b73086824124"></span><em class="property">virtual</em> std::pair&lt;std::shared_ptr&lt;framework::Buffer&gt;, std::vector&lt;std::shared_ptr&lt;session::<a class="reference internal" href="#_CPPv4N5arrus7session8MetadataE" title="arrus::session::Metadata">Metadata</a>&gt;&gt;&gt; <code class="sig-name descname">setSubsequences</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;Slice&gt; &amp;<em>slices</em>, <em class="property">const</em> std::vector&lt;std::optional&lt;float&gt;&gt; &amp;<em>sris</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R15setSubsequencesERKNSt6vectorI5SliceEERKNSt6vectorINSt8optionalIfEEEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Selects [start, end) slices for each sub-sequence.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">slices</span></code> array should have exactly n elements, where n is the number of currently uploaded sequences. The element slice[i] sets the [start, end) range for the i-th sequence.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">sris</span></code> should have eactly n elements, or should be empty (which means that no additional sri should be applied).</p>
<p>To turn off the given sequence, just set start equal to end (e.g. Slice(0, 0)). For such sequences, the metadata will describe only empty data (dummy metadata).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>slices</strong> – slices to set to each Scheme sub-sequence </p></li>
<li><p><strong>sris</strong> – sris to apply to each Scheme sub-sequence </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>returns the buffer and metadata for the modified Scheme. The metadata array size is always equal to the number of seqeuences in the original Scheme </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R8getProbeE7Ordinal">
<span id="_CPPv3N5arrus7devices4Us4R8getProbeE7Ordinal"></span><span id="_CPPv2N5arrus7devices4Us4R8getProbeE7Ordinal"></span><span id="arrus::devices::Us4R::getProbe__Ordinal"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1aea29947c69d379f222782a640f60620c"></span><em class="property">virtual</em> Probe *<code class="sig-name descname">getProbe</code><span class="sig-paren">(</span>Ordinal <em>ordinal</em><span class="sig-paren">)</span> <em class="property">override</em> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R8getProbeE7Ordinal" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns probe identified by given ordinal number.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ordinal</strong> – ordinal number of the probe to get </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>probe handle </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R21setMaximumPulseLengthENSt8optionalIfEE">
<span id="_CPPv3N5arrus7devices4Us4R21setMaximumPulseLengthENSt8optionalIfEE"></span><span id="_CPPv2N5arrus7devices4Us4R21setMaximumPulseLengthENSt8optionalIfEE"></span><span id="arrus::devices::Us4R::setMaximumPulseLength__std::optional:float:"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1afbd7e3e4daa29fb78307fdd630ef4ae3"></span><em class="property">virtual</em> void <code class="sig-name descname">setMaximumPulseLength</code><span class="sig-paren">(</span>std::optional&lt;float&gt; <em>maxLength</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R21setMaximumPulseLengthENSt8optionalIfEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets maximum pulse length that can be set during the TX/RX sequence programming FOR THE AMPLITUDE 2 / RAIL HV 0.</p>
<p><strong>NOTE this method is intended to be used only for the probe health check! DO NOT USE THIS METHOD TO SET THE MAXIMUM TX PULSE LENGTH e.g. FOR THE IMAGING PURPOSES.</strong></p>
<p>std::nullopt means to use up to 32 TX cycles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>maxLength</strong> – maximum pulse length (s) nullopt means to use 32 TX cycles (legacy OEM constraint) </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R20getActualTxFrequencyEf">
<span id="_CPPv3N5arrus7devices4Us4R20getActualTxFrequencyEf"></span><span id="_CPPv2N5arrus7devices4Us4R20getActualTxFrequencyEf"></span><span id="arrus::devices::Us4R::getActualTxFrequency__float"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a2140a75e43c74d048b39494b85e1aae8"></span><em class="property">virtual</em> float <code class="sig-name descname">getActualTxFrequency</code><span class="sig-paren">(</span>float <em>frequency</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R20getActualTxFrequencyEf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the system TX frequency that would be actually set for the given TX frequency. The output frequency depends on the frequency discretization performed by the driver.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>frequency</strong> – input frequency </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the actual frequency that will be set </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus7devices4Us4R18getMinimumTGCValueEv">
<span id="_CPPv3NK5arrus7devices4Us4R18getMinimumTGCValueEv"></span><span id="_CPPv2NK5arrus7devices4Us4R18getMinimumTGCValueEv"></span><span id="arrus::devices::Us4R::getMinimumTGCValueC"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a2503ce5be143e2a2f1e9569905ae4cf7"></span><em class="property">virtual</em> float <code class="sig-name descname">getMinimumTGCValue</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> = 0<a class="headerlink" href="#_CPPv4NK5arrus7devices4Us4R18getMinimumTGCValueEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns minimum available TGC value, according to the currently set parameters. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus7devices4Us4R18getMaximumTGCValueEv">
<span id="_CPPv3NK5arrus7devices4Us4R18getMaximumTGCValueEv"></span><span id="_CPPv2NK5arrus7devices4Us4R18getMaximumTGCValueEv"></span><span id="arrus::devices::Us4R::getMaximumTGCValueC"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a306a3c331d07cc7b7750d6c47afa90f2"></span><em class="property">virtual</em> float <code class="sig-name descname">getMaximumTGCValue</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> = 0<a class="headerlink" href="#_CPPv4NK5arrus7devices4Us4R18getMaximumTGCValueEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns maximum available TGC value, according to the currently set parameters. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R13disableAllHpfEv">
<span id="_CPPv3N5arrus7devices4Us4R13disableAllHpfEv"></span><span id="_CPPv2N5arrus7devices4Us4R13disableAllHpfEv"></span><span id="arrus::devices::Us4R::disableAllHpf"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a2e207a739d1317dc18a6b2a2779d68dc"></span><em class="property">virtual</em> void <code class="sig-name descname">disableAllHpf</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R13disableAllHpfEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Disables all high-pass filters on the device. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices4Us4R10getVariantEv">
<span id="_CPPv3N5arrus7devices4Us4R10getVariantEv"></span><span id="_CPPv2N5arrus7devices4Us4R10getVariantEv"></span><span id="arrus::devices::Us4R::getVariant"></span><span class="target" id="classarrus_1_1devices_1_1Us4R_1a6bd544ea95638b81f7cd99ba1d2b92a4"></span><em class="property">virtual</em> <a class="reference internal" href="#_CPPv4N5arrus7devices6Us4OEME" title="arrus::devices::Us4OEM">Us4OEM</a>::Variant <code class="sig-name descname">getVariant</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices4Us4R10getVariantEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns system variant (LEGACY/PLUS_32RX. etc.). </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrus7devices12Us4RSettingsE">
<span id="_CPPv3N5arrus7devices12Us4RSettingsE"></span><span id="_CPPv2N5arrus7devices12Us4RSettingsE"></span><span id="arrus::devices::Us4RSettings"></span><span class="target" id="classarrus_1_1devices_1_1Us4RSettings"></span><em class="property">class </em><code class="sig-prename descclassname">arrus::devices<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">Us4RSettings</code><a class="headerlink" href="#_CPPv4N5arrus7devices12Us4RSettingsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#classarrus_1_1devices_1_1Us4R"><span class="std std-ref">Us4R</span></a> device settings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>probeAdapterSettings</strong> – Probe adapter settings. Optional - when not set, at least one <a class="reference internal" href="#classarrus_1_1devices_1_1Us4OEMSettings"><span class="std std-ref">Us4OEMSettings</span></a> must be set. When is set, the list of <a class="reference internal" href="#classarrus_1_1devices_1_1Us4OEM"><span class="std std-ref">Us4OEM</span></a> settings should be empty. </p></li>
<li><p><strong>probeSettings</strong> – List of ProbeSettings to set. Optional - when is set, ProbeAdapterSettings also </p></li>
<li><p><strong>rxSettings</strong> – initial RX (AFE) settings </p></li>
<li><p><strong>hvSettings</strong> – high-voltage supplier settings, Optional (us4r devices may have externally controlled hv suppliers). </p></li>
<li><p><strong>channelsMask</strong> – A set of channels that should be turned off in the us4r system. This is list of lists; each list represents what channels of the ultrasound interface (probe) should be turned off. channelsMask[i] is a channels mask for the i-th probe (Probe:i). Note that the **channel numbers start from 0 </p></li>
<li><p><strong>reprogrammingMode</strong> – reprogramming mode applied to all us4OEMs. See <a class="reference internal" href="#classarrus_1_1devices_1_1Us4OEMSettings_1a1e5a04b3f928a64a3589efb60747f21b"><span class="std std-ref">Us4OEMSettings::ReprogrammingMode</span></a> docs for more information. </p></li>
<li><p><strong>nUs4OEMs</strong> – number of us4OEMs in the us4R system. Optional, if is std::nullopt, the number of us4oems is determined based on the probe adapter mapping (equal to the maximum ordinal number of us4OEM). Optional, if set to std::nullopt, the number of us4OEMs will be determined based on the probe adapter mapping (as the maximum of us4OEM module ordinal numbers). </p></li>
<li><p><strong>adapterToUs4RModuleNumber</strong> – The mapping from the us4OEM ordinal number in the probe adapter mapping and the actual ordinal number of us4OEM. Optional, empty vector means that no mapping should be applied (identity mapping). </p></li>
<li><p><strong>externalTrigger</strong> – whether the external trigger (TRIG INPUT) should be enabled </p></li>
<li><p><strong>txFrequencyRange</strong> – Transmit frequency range to set on us4OEM devices. Actually, TX frequency divider. </p></li>
<li><p><strong>digitalBackplaneSettings</strong> – digital backplane (“DBAR”) settings. If not provided, the software will try to determine DBAR model based on select HV supplier. </p></li>
<li><p><strong>bitstreams</strong> – us4OEM I/O bitstream definitions </p></li>
<li><p><strong>limits</strong> – TX/RX constraints to apply on the system (e.g. minimum/maximum voltage, etc.). </p></li>
<li><p><strong>watchdogSettings</strong> – us4OEM+ watchdog settings. </p></li>
<li><p><strong>allowDuplicateOEMIds</strong> – whether we should allow to run system with duplicate OEM ids (e.g. due to connectivity issues). </p></li>
</ul>
</dd>
</dl>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4NK5arrus7devices12Us4RSettings16getProbeSettingsEv">
<span id="_CPPv3NK5arrus7devices12Us4RSettings16getProbeSettingsEv"></span><span id="_CPPv2NK5arrus7devices12Us4RSettings16getProbeSettingsEv"></span><span id="arrus::devices::Us4RSettings::getProbeSettingsC"></span><span class="target" id="classarrus_1_1devices_1_1Us4RSettings_1afb64061c0d69cc7c93dc8c7f6c1124df"></span><em class="property">inline</em> std::optional&lt;ProbeSettings&gt; <code class="sig-name descname">getProbeSettings</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrus7devices12Us4RSettings16getProbeSettingsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns probe settings for probe 0. TODO (ARRUS-276) deprecated, will be removed in v0.12.0 </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus7devices12Us4RSettings15getChannelsMaskEv">
<span id="_CPPv3NK5arrus7devices12Us4RSettings15getChannelsMaskEv"></span><span id="_CPPv2NK5arrus7devices12Us4RSettings15getChannelsMaskEv"></span><span id="arrus::devices::Us4RSettings::getChannelsMaskC"></span><span class="target" id="classarrus_1_1devices_1_1Us4RSettings_1aa309b5cc7b811f1cc9744a598cbaf300"></span><em class="property">inline</em> <em class="property">const</em> std::unordered_set&lt;ChannelIdx&gt; &amp;<code class="sig-name descname">getChannelsMask</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrus7devices12Us4RSettings15getChannelsMaskEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns channels mask to be applied for Probe:0 TX/RX apertures. DEPRECATED (v0.11.0): please use getChannelsMask(probeNr). </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrus7devices14Us4RTxRxLimitsE">
<span id="_CPPv3N5arrus7devices14Us4RTxRxLimitsE"></span><span id="_CPPv2N5arrus7devices14Us4RTxRxLimitsE"></span><span id="arrus::devices::Us4RTxRxLimits"></span><span class="target" id="classarrus_1_1devices_1_1Us4RTxRxLimits"></span><em class="property">class </em><code class="sig-name descname">Us4RTxRxLimits</code><a class="headerlink" href="#_CPPv4N5arrus7devices14Us4RTxRxLimitsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Custom TX/RX limits to be applied on the TX/RX sequence validation. NOTE: all the values are optional; nullopt means that the default value for a given us4OEM revision will be used. </p>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5us4us4us4r10RxSettingsE">
<span id="_CPPv3N5us4us4us4r10RxSettingsE"></span><span id="_CPPv2N5us4us4us4r10RxSettingsE"></span><span id="us4us::us4r::RxSettings"></span><span class="target" id="classus4us_1_1us4r_1_1RxSettings"></span><em class="property">class </em><code class="sig-prename descclassname">us4us::us4r<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">RxSettings</code><a class="headerlink" href="#_CPPv4N5us4us4us4r10RxSettingsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>AFE (RX) settings.</p>
<p>NOTE: to create the instance of this object please use the <a class="reference internal" href="#classus4us_1_1us4r_1_1RxSettingsBuilder"><span class="std std-ref">RxSettingsBuilder</span></a>.</p>
<p>Us4R AFE settings currently includes: AFE 58JD18:<ul class="simple">
<li><p>DTGC attenuation, available: 0, 6, 12, 18, 24, 30, 36, 42 [dB] or std::nullopt; nullopt turns off DTGC.</p></li>
<li><p>LNA gain, available: 12, 18, 24 [dB].</p></li>
<li><p>PGA gain, available: 24, 30 [dB].</p></li>
<li><p>TGC samples: analog TGC curve samples [dB]. Up to 1022 samples. TGC samples should be in range [min, max](closed interval) where min = (lna gain + pga gain)-36, and max = (lna gain, pga gain). Empty list turns off analog TGC.</p></li>
<li><p>Active termination, available: 50, 100, 200, 400 [Ohm] or std::nullopt. null opt turns off active termination</p></li>
<li><p>LPF cutoff, available: 10000000, 15000000, 20000000, 30000000, 35000000, 50000000 [Hz].</p></li>
<li><p>applyTgcCharacteristic: whether to apply pre-computed (by us4us) TGC response characteristic, so that the observed gain better corresponds to the applied one.</p></li>
</ul>
</p>
<p>Constraints:<ul class="simple">
<li><p>only one of the following can be turned on: DTGC or analog TGC.</p></li>
<li><p>when applyTgcCharacteristic == true, LNA and PGA gain has to be (current limitation of the selected TGC characteristic). </p></li>
</ul>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5us4us4us4r10RxSettings10RxSettingsERKNSt8optionalI8uint16_tEE8uint16_t8uint16_tNSt6vectorIfEE8uint32_tRKNSt8optionalI8uint16_tEEb">
<span id="_CPPv3N5us4us4us4r10RxSettings10RxSettingsERKNSt8optionalI8uint16_tEE8uint16_t8uint16_tNSt6vectorIfEE8uint32_tRKNSt8optionalI8uint16_tEEb"></span><span id="_CPPv2N5us4us4us4r10RxSettings10RxSettingsERKNSt8optionalI8uint16_tEE8uint16_t8uint16_tNSt6vectorIfEE8uint32_tRKNSt8optionalI8uint16_tEEb"></span><span id="us4us::us4r::RxSettings::RxSettings__std::optional:uint16_t:CR.uint16_t.uint16_t.std::vector:float:.uint32_t.std::optional:uint16_t:CR.b"></span><span class="target" id="classus4us_1_1us4r_1_1RxSettings_1a43a652357ca6a0bfeedb0bf2e3fdbe32"></span><em class="property">inline</em> <code class="sig-name descname">RxSettings</code><span class="sig-paren">(</span><em class="property">const</em> std::optional&lt;uint16_t&gt; &amp;<em>dtgcAttenuation</em>, uint16_t <em>pgaGain</em>, uint16_t <em>lnaGain</em>, std::vector&lt;float&gt; <em>tgcSamples</em>, uint32_t <em>lpfCutoff</em>, <em class="property">const</em> std::optional&lt;uint16_t&gt; &amp;<em>activeTermination</em>, bool <em>applyTgcCharacteristic</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5us4us4us4r10RxSettings10RxSettingsERKNSt8optionalI8uint16_tEE8uint16_t8uint16_tNSt6vectorIfEE8uint32_tRKNSt8optionalI8uint16_tEEb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Creates RX settings for the given parameters.</p>
<p><dl class="xrefsect">
<dt>
<em>Deprecated:</em></dt>
<dd><p>will be removed in ARRUS 0.15.0, please use <a class="reference internal" href="#classus4us_1_1us4r_1_1RxSettingsBuilder"><span class="std std-ref">RxSettingsBuilder</span></a> instead. </p>
</dd></dl>

</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-static-functions">Public Static Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5us4us4us4r10RxSettings12getTgcMinMaxE8uint16_t8uint16_tf">
<span id="_CPPv3N5us4us4us4r10RxSettings12getTgcMinMaxE8uint16_t8uint16_tf"></span><span id="_CPPv2N5us4us4us4r10RxSettings12getTgcMinMaxE8uint16_t8uint16_tf"></span><span id="us4us::us4r::RxSettings::getTgcMinMax__uint16_t.uint16_t.float"></span><span class="target" id="classus4us_1_1us4r_1_1RxSettings_1a1f602d8f52af52ae2a2024993a5ac05d"></span><em class="property">static</em> <em class="property">inline</em> std::pair&lt;float, float&gt; <code class="sig-name descname">getTgcMinMax</code><span class="sig-paren">(</span>uint16_t <em>pgaGain</em>, uint16_t <em>lnaGain</em>, float <em>attenuationRange</em> = <a class="reference internal" href="#_CPPv4N5us4us4us4r10RxSettingsE" title="us4us::us4r::RxSettings">RxSettings</a>::AFE58JD18_TGC_ATTENUATION_RANGE<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5us4us4us4r10RxSettings12getTgcMinMaxE8uint16_t8uint16_tf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A helper function that computes a pair of (min, max) acceptable analog TGC gain for given PGA and LNA gain values.</p>
<p>NOTE: this method assumes that AFE58JD18 device is used (65 MHz sampling frequency). For OEM+HF (120 MHz), please use AFE58JD48_TGC_ATTENUATION_RANGE.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pgaGain</strong> – PGA gain value to consider </p></li>
<li><p><strong>lnaGain</strong> – LNA gain value to consider </p></li>
<li><p><strong>attenuationRange</strong> – AFE attenuation range, by default 65 MHz OEM attenuation range is assumed (AFE58JD18). </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a pair (min, max) acceptable sample value. </p>
</dd>
</dl>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5us4us4us4r17RxSettingsBuilderE">
<span id="_CPPv3N5us4us4us4r17RxSettingsBuilderE"></span><span id="_CPPv2N5us4us4us4r17RxSettingsBuilderE"></span><span id="us4us::us4r::RxSettingsBuilder"></span><span class="target" id="classus4us_1_1us4r_1_1RxSettingsBuilder"></span><em class="property">class </em><code class="sig-name descname">RxSettingsBuilder</code><a class="headerlink" href="#_CPPv4N5us4us4us4r17RxSettingsBuilderE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#classus4us_1_1us4r_1_1RxSettings"><span class="std std-ref">RxSettings</span></a> builder. </p>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrus7devices16WatchdogSettingsE">
<span id="_CPPv3N5arrus7devices16WatchdogSettingsE"></span><span id="_CPPv2N5arrus7devices16WatchdogSettingsE"></span><span id="arrus::devices::WatchdogSettings"></span><span class="target" id="classarrus_1_1devices_1_1WatchdogSettings"></span><em class="property">class </em><code class="sig-name descname">WatchdogSettings</code><a class="headerlink" href="#_CPPv4N5arrus7devices16WatchdogSettingsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>us4OEM+ watchdog settings.</p>
<p>You can disable us4OEM watchdog settings using WatchdogSettings::disabled().</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>oemThreshold0</strong> – How long can the host remain unresponsive before the OEM sends a warning interrupt [s] </p></li>
<li><p><strong>oemThreshold1</strong> – How long can the host remain unresponsive before the OEM turns off [s] </p></li>
<li><p><strong>hostThreshold</strong> – How long can the OEM can remain unresponsive before the host stops the current TX/RX sequence [s] </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrus7devices14Us4OEMSettingsE">
<span id="_CPPv3N5arrus7devices14Us4OEMSettingsE"></span><span id="_CPPv2N5arrus7devices14Us4OEMSettingsE"></span><span id="arrus::devices::Us4OEMSettings"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEMSettings"></span><em class="property">class </em><code class="sig-prename descclassname">arrus::devices<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">Us4OEMSettings</code><a class="headerlink" href="#_CPPv4N5arrus7devices14Us4OEMSettingsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#classarrus_1_1devices_1_1Us4OEM"><span class="std std-ref">Us4OEM</span></a> settings.</p>
<p>Contains all raw parameters used to configure module. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-types">Public Types</p>
<dl class="cpp enum-class">
<dt id="_CPPv4N5arrus7devices14Us4OEMSettings17ReprogrammingModeE">
<span id="_CPPv3N5arrus7devices14Us4OEMSettings17ReprogrammingModeE"></span><span id="_CPPv2N5arrus7devices14Us4OEMSettings17ReprogrammingModeE"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEMSettings_1a1e5a04b3f928a64a3589efb60747f21b"></span><em class="property">enum class </em><code class="sig-name descname">ReprogrammingMode</code><a class="headerlink" href="#_CPPv4N5arrus7devices14Us4OEMSettings17ReprogrammingModeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determines when the us4OEM FPGA reprogramming starts.</p>
<p>SEQUENTIAL: <a class="reference internal" href="#classarrus_1_1devices_1_1Us4OEM"><span class="std std-ref">Us4OEM</span></a> FPGA reprogramming starts after signal data acquisition is ended. Total TX/RX time: rx time + reprogramming time. Total TX/RX time determines possible maximum PRF. This mode minimizes signal noise at the expense of additional reprogramming time (which decreases available PRF).</p>
<p>PARALLEL: <a class="reference internal" href="#classarrus_1_1devices_1_1Us4OEM"><span class="std std-ref">Us4OEM</span></a> FPGA reprogramming for the next TX starts when the the current TX is triggered; both processes (reprogramming for the next TX/RX and current TX/RX) are done in parallel. Total TX/RX time: max(rx time, reprogramming time). Total TX/RX time determines possible maximum PRF. This mode maximizes the possible PRF at the expense of additional noise that may appear at the beginning of the data (emitted during the FPGA reprogramming). </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt id="_CPPv4N5arrus7devices14Us4OEMSettings17ReprogrammingMode10SEQUENTIALE">
<span id="_CPPv3N5arrus7devices14Us4OEMSettings17ReprogrammingMode10SEQUENTIALE"></span><span id="_CPPv2N5arrus7devices14Us4OEMSettings17ReprogrammingMode10SEQUENTIALE"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEMSettings_1a1e5a04b3f928a64a3589efb60747f21ba39403cd282d944abcd4f14996cb71bcb"></span><em class="property">enumerator </em><code class="sig-name descname">SEQUENTIAL</code><a class="headerlink" href="#_CPPv4N5arrus7devices14Us4OEMSettings17ReprogrammingMode10SEQUENTIALE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="cpp enumerator">
<dt id="_CPPv4N5arrus7devices14Us4OEMSettings17ReprogrammingMode8PARALLELE">
<span id="_CPPv3N5arrus7devices14Us4OEMSettings17ReprogrammingMode8PARALLELE"></span><span id="_CPPv2N5arrus7devices14Us4OEMSettings17ReprogrammingMode8PARALLELE"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEMSettings_1a1e5a04b3f928a64a3589efb60747f21badf13a99b035d6f0bce4f44ab18eec8eb"></span><em class="property">enumerator </em><code class="sig-name descname">PARALLEL</code><a class="headerlink" href="#_CPPv4N5arrus7devices14Us4OEMSettings17ReprogrammingMode8PARALLELE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices14Us4OEMSettings14Us4OEMSettingsE14ChannelMapping10RxSettings17ReprogrammingModei">
<span id="_CPPv3N5arrus7devices14Us4OEMSettings14Us4OEMSettingsE14ChannelMapping10RxSettings17ReprogrammingModei"></span><span id="_CPPv2N5arrus7devices14Us4OEMSettings14Us4OEMSettingsE14ChannelMapping10RxSettings17ReprogrammingModei"></span><span id="arrus::devices::Us4OEMSettings::Us4OEMSettings__ChannelMapping.RxSettings.ReprogrammingMode.i"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEMSettings_1a32fddf0de1087eeb36b7bbdb82b2a844"></span><em class="property">inline</em> <code class="sig-name descname">Us4OEMSettings</code><span class="sig-paren">(</span>ChannelMapping <em>channelMapping</em>, RxSettings <em>rxSettings</em>, <a class="reference internal" href="#_CPPv4N5arrus7devices14Us4OEMSettings17ReprogrammingModeE" title="arrus::devices::Us4OEMSettings::ReprogrammingMode">ReprogrammingMode</a> <em>reprogrammingMode</em> = <a class="reference internal" href="#_CPPv4N5arrus7devices14Us4OEMSettings17ReprogrammingModeE" title="arrus::devices::Us4OEMSettings::ReprogrammingMode">ReprogrammingMode</a>::<a class="reference internal" href="#_CPPv4N5arrus7devices14Us4OEMSettings17ReprogrammingMode10SEQUENTIALE" title="arrus::devices::Us4OEMSettings::ReprogrammingMode::SEQUENTIAL">SEQUENTIAL</a>, int <em>txFrequencyRange</em> = 1<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrus7devices14Us4OEMSettings14Us4OEMSettingsE14ChannelMapping10RxSettings17ReprogrammingModei" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#classarrus_1_1devices_1_1Us4OEM"><span class="std std-ref">Us4OEM</span></a> Settings constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>channelMapping</strong> – channel permutation to apply on a given <a class="reference internal" href="#classarrus_1_1devices_1_1Us4OEM"><span class="std std-ref">Us4OEM</span></a>. channelMapping[i] = j, where <code class="docutils literal notranslate"><span class="pre">i</span></code> is the virtual(logical) channel number, <code class="docutils literal notranslate"><span class="pre">j</span></code> is the physical channel number. </p></li>
<li><p><strong>rxSettings</strong> – initial rx settings to apply </p></li>
<li><p><strong>reprogrammingMode</strong> – us4OEM reprogramming mode </p></li>
<li><p><strong>txFrequencyRange</strong> – tx frequency range, actually: tx frequency divider, by default 1 is used. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrus7devices6Us4OEME">
<span id="_CPPv3N5arrus7devices6Us4OEME"></span><span id="_CPPv2N5arrus7devices6Us4OEME"></span><span id="arrus::devices::Us4OEM"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM"></span><em class="property">class </em><code class="sig-prename descclassname">arrus::devices<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">Us4OEM</code> : <em class="property">public</em> arrus::devices::Device, <em class="property">public</em> arrus::devices::TriggerGenerator<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEME" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-types">Public Types</p>
<dl class="cpp enum-class">
<dt id="_CPPv4N5arrus7devices6Us4OEM13RxTestPatternE">
<span id="_CPPv3N5arrus7devices6Us4OEM13RxTestPatternE"></span><span id="_CPPv2N5arrus7devices6Us4OEM13RxTestPatternE"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1a8688cd3e199fb27328163ba044ec59ab"></span><em class="property">enum class </em><code class="sig-name descname">RxTestPattern</code><a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM13RxTestPatternE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#classarrus_1_1devices_1_1Us4OEM"><span class="std std-ref">Us4OEM</span></a> ADC test pattern state. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt id="_CPPv4N5arrus7devices6Us4OEM13RxTestPattern3OFFE">
<span id="_CPPv3N5arrus7devices6Us4OEM13RxTestPattern3OFFE"></span><span id="_CPPv2N5arrus7devices6Us4OEM13RxTestPattern3OFFE"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1a8688cd3e199fb27328163ba044ec59aba88559a0cfd8250c9d65970cc145c92d4"></span><em class="property">enumerator </em><code class="sig-name descname">OFF</code><a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM13RxTestPattern3OFFE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="cpp enumerator">
<dt id="_CPPv4N5arrus7devices6Us4OEM13RxTestPattern4RAMPE">
<span id="_CPPv3N5arrus7devices6Us4OEM13RxTestPattern4RAMPE"></span><span id="_CPPv2N5arrus7devices6Us4OEM13RxTestPattern4RAMPE"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1a8688cd3e199fb27328163ba044ec59abaf89e1aea17dcf73105f3c89a72d3df3c"></span><em class="property">enumerator </em><code class="sig-name descname">RAMP</code><a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM13RxTestPattern4RAMPE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Ramp (sawtooth data pattern). </p>
</dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM20getSamplingFrequencyEv">
<span id="_CPPv3N5arrus7devices6Us4OEM20getSamplingFrequencyEv"></span><span id="_CPPv2N5arrus7devices6Us4OEM20getSamplingFrequencyEv"></span><span id="arrus::devices::Us4OEM::getSamplingFrequency"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1aaf48bd83ddcca34b103b36192e2efe58"></span><em class="property">virtual</em> float <code class="sig-name descname">getSamplingFrequency</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM20getSamplingFrequencyEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns nominal sampling frequency on the us4OEM device. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus7devices6Us4OEM27getCurrentSamplingFrequencyEv">
<span id="_CPPv3NK5arrus7devices6Us4OEM27getCurrentSamplingFrequencyEv"></span><span id="_CPPv2NK5arrus7devices6Us4OEM27getCurrentSamplingFrequencyEv"></span><span id="arrus::devices::Us4OEM::getCurrentSamplingFrequencyC"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1ae83a3a6716d05f5e5be60656437c10ee"></span><em class="property">virtual</em> float <code class="sig-name descname">getCurrentSamplingFrequency</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> = 0<a class="headerlink" href="#_CPPv4NK5arrus7devices6Us4OEM27getCurrentSamplingFrequencyEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns current sampling frequency of the us4OEM device. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM18getFPGATemperatureEv">
<span id="_CPPv3N5arrus7devices6Us4OEM18getFPGATemperatureEv"></span><span id="_CPPv2N5arrus7devices6Us4OEM18getFPGATemperatureEv"></span><span id="arrus::devices::Us4OEM::getFPGATemperature"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1a2b409ccde271e5bcc02d85889cca3cfc"></span><em class="property">virtual</em> float <code class="sig-name descname">getFPGATemperature</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM18getFPGATemperatureEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns temperature measured by <a class="reference internal" href="#classarrus_1_1devices_1_1Us4OEM"><span class="std std-ref">Us4OEM</span></a>’s FPGA [Celsius]. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM17getUCDTemperatureEv">
<span id="_CPPv3N5arrus7devices6Us4OEM17getUCDTemperatureEv"></span><span id="_CPPv2N5arrus7devices6Us4OEM17getUCDTemperatureEv"></span><span id="arrus::devices::Us4OEM::getUCDTemperature"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1afb702fb805f85a3519ba49b37700e0b1"></span><em class="property">virtual</em> float <code class="sig-name descname">getUCDTemperature</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM17getUCDTemperatureEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns temperature measured by <a class="reference internal" href="#classarrus_1_1devices_1_1Us4OEM"><span class="std std-ref">Us4OEM</span></a>’s UCD [Celsius] </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM25getUCDExternalTemperatureEv">
<span id="_CPPv3N5arrus7devices6Us4OEM25getUCDExternalTemperatureEv"></span><span id="_CPPv2N5arrus7devices6Us4OEM25getUCDExternalTemperatureEv"></span><span id="arrus::devices::Us4OEM::getUCDExternalTemperature"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1a8989ba2db27056876e8064a79c785c98"></span><em class="property">virtual</em> float <code class="sig-name descname">getUCDExternalTemperature</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM25getUCDExternalTemperatureEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns external temperature measured by <a class="reference internal" href="#classarrus_1_1devices_1_1Us4OEM"><span class="std std-ref">Us4OEM</span></a>’s UCD [Celsius] </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM21getUCDMeasuredVoltageE7uint8_t">
<span id="_CPPv3N5arrus7devices6Us4OEM21getUCDMeasuredVoltageE7uint8_t"></span><span id="_CPPv2N5arrus7devices6Us4OEM21getUCDMeasuredVoltageE7uint8_t"></span><span id="arrus::devices::Us4OEM::getUCDMeasuredVoltage__uint8_t"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1a60b70426a585ebb01776883f28d6ae12"></span><em class="property">virtual</em> float <code class="sig-name descname">getUCDMeasuredVoltage</code><span class="sig-paren">(</span>uint8_t <em>rail</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM21getUCDMeasuredVoltageE7uint8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns rail voltage measured by <a class="reference internal" href="#classarrus_1_1devices_1_1Us4OEM"><span class="std std-ref">Us4OEM</span></a>’s UCD [V].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rail</strong> – UCD rail number </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM21getMeasuredHVPVoltageEv">
<span id="_CPPv3N5arrus7devices6Us4OEM21getMeasuredHVPVoltageEv"></span><span id="_CPPv2N5arrus7devices6Us4OEM21getMeasuredHVPVoltageEv"></span><span id="arrus::devices::Us4OEM::getMeasuredHVPVoltage"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1ad0d74be83bee3f747a741ca03ed98536"></span><em class="property">virtual</em> float <code class="sig-name descname">getMeasuredHVPVoltage</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM21getMeasuredHVPVoltageEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns rail voltage measured by <a class="reference internal" href="#classarrus_1_1devices_1_1Us4OEM"><span class="std std-ref">Us4OEM</span></a>’s UCD [V].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rail</strong> – UCD rail number </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM21getMeasuredHVMVoltageEv">
<span id="_CPPv3N5arrus7devices6Us4OEM21getMeasuredHVMVoltageEv"></span><span id="_CPPv2N5arrus7devices6Us4OEM21getMeasuredHVMVoltageEv"></span><span id="arrus::devices::Us4OEM::getMeasuredHVMVoltage"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1a2164a7687cad4782d0a8ef1eb159de21"></span><em class="property">virtual</em> float <code class="sig-name descname">getMeasuredHVMVoltage</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM21getMeasuredHVMVoltageEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns rail voltage measured by <a class="reference internal" href="#classarrus_1_1devices_1_1Us4OEM"><span class="std std-ref">Us4OEM</span></a>’s UCD [V].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rail</strong> – UCD rail number </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM6getAfeE7uint8_t">
<span id="_CPPv3N5arrus7devices6Us4OEM6getAfeE7uint8_t"></span><span id="_CPPv2N5arrus7devices6Us4OEM6getAfeE7uint8_t"></span><span id="arrus::devices::Us4OEM::getAfe__uint8_t"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1a9eeca0d17001f544eab3dc43e46593b0"></span><em class="property">virtual</em> uint16_t <code class="sig-name descname">getAfe</code><span class="sig-paren">(</span>uint8_t <em>address</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM6getAfeE7uint8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reads AFE register</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>address</strong> – register address </p>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><p><strong>arrus::IllegalStateException</strong> – when invalid input parameters detected </p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>: register value </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM6setAfeE7uint8_t8uint16_t">
<span id="_CPPv3N5arrus7devices6Us4OEM6setAfeE7uint8_t8uint16_t"></span><span id="_CPPv2N5arrus7devices6Us4OEM6setAfeE7uint8_t8uint16_t"></span><span id="arrus::devices::Us4OEM::setAfe__uint8_t.uint16_t"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1a060d208d9f29f0d00a0f6d87650134ce"></span><em class="property">virtual</em> void <code class="sig-name descname">setAfe</code><span class="sig-paren">(</span>uint8_t <em>address</em>, uint16_t <em>value</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM6setAfeE7uint8_t8uint16_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Writes AFE register</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>address</strong> – register address </p></li>
<li><p><strong>value</strong> – register value </p></li>
</ul>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><p><strong>arrus::IllegalStateException</strong> – when invalid input parameters detected </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM11setAfeDemodEffPKf6size_tf">
<span id="_CPPv3N5arrus7devices6Us4OEM11setAfeDemodEffPKf6size_tf"></span><span id="_CPPv2N5arrus7devices6Us4OEM11setAfeDemodEffPKf6size_tf"></span><span id="arrus::devices::Us4OEM::setAfeDemod__float.float.floatCP.s.float"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1a7c410e418169cb7aff03eb45aea99fdb"></span><em class="property">virtual</em> void <code class="sig-name descname">setAfeDemod</code><span class="sig-paren">(</span>float <em>demodulationFrequency</em>, float <em>decimationFactor</em>, <em class="property">const</em> float *<em>firCoefficients</em>, size_t <em>nCoefficients</em>, float <em>gain</em> = 12<span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM11setAfeDemodEffPKf6size_tf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Enables and configures AFE built-in demodulator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>demodulationFrequency</strong> – Demodulation frequency </p></li>
<li><p><strong>decimationFactor</strong> – Decimation factor </p></li>
<li><p><strong>firCoefficients</strong> – Pointer to Low pass filter coefficients buffer </p></li>
<li><p><strong>nCoefficients</strong> – Number of FIR coefficients </p></li>
<li><p><strong>gain</strong> – an extra digital gain to apply (after decimation filter), by default set to 12 dB. Currently only 0 and 12 dB are supported [dB] </p></li>
</ul>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><p><strong>arrus::IllegalStateException</strong> – when invalid input parameters detected </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM15disableAfeDemodEv">
<span id="_CPPv3N5arrus7devices6Us4OEM15disableAfeDemodEv"></span><span id="_CPPv2N5arrus7devices6Us4OEM15disableAfeDemodEv"></span><span id="arrus::devices::Us4OEM::disableAfeDemod"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1af2f4c42de141a9ad132a784906374bf0"></span><em class="property">virtual</em> void <code class="sig-name descname">disableAfeDemod</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM15disableAfeDemodEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Disables AFE built-in demodulator </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM20checkFirmwareVersionEv">
<span id="_CPPv3N5arrus7devices6Us4OEM20checkFirmwareVersionEv"></span><span id="_CPPv2N5arrus7devices6Us4OEM20checkFirmwareVersionEv"></span><span id="arrus::devices::Us4OEM::checkFirmwareVersion"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1a46b39fcfaa3f37217879a84e0d512c00"></span><em class="property">virtual</em> void <code class="sig-name descname">checkFirmwareVersion</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM20checkFirmwareVersionEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Checks if the firmware version on the <a class="reference internal" href="#classarrus_1_1devices_1_1Us4OEM"><span class="std std-ref">Us4OEM</span></a> module is correct.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>arrus::IllegalStateException</strong> – when the incorrect version was detected. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM10checkStateEv">
<span id="_CPPv3N5arrus7devices6Us4OEM10checkStateEv"></span><span id="_CPPv2N5arrus7devices6Us4OEM10checkStateEv"></span><span id="arrus::devices::Us4OEM::checkState"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1a0037aaf01b39e41f18176cc3f67c3258"></span><em class="property">virtual</em> void <code class="sig-name descname">checkState</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM10checkStateEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Checks if the us4OEM is in the correct state (as seen by host PC).</p>
<p>Note: currently only the firmware version is checked (to verify if the us4OEM module memory space is still available for the us4OEM module).</p>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>arrus::IllegalStateException</strong> – when the incorrect version was detected. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM18getFirmwareVersionEv">
<span id="_CPPv3N5arrus7devices6Us4OEM18getFirmwareVersionEv"></span><span id="_CPPv2N5arrus7devices6Us4OEM18getFirmwareVersionEv"></span><span id="arrus::devices::Us4OEM::getFirmwareVersion"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1a010362855bfee7a49fbab86a4cb58723"></span><em class="property">virtual</em> uint32 <code class="sig-name descname">getFirmwareVersion</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM18getFirmwareVersionEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns firmware version installed on the us4OEM module. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM20getTxFirmwareVersionEv">
<span id="_CPPv3N5arrus7devices6Us4OEM20getTxFirmwareVersionEv"></span><span id="_CPPv2N5arrus7devices6Us4OEM20getTxFirmwareVersionEv"></span><span id="arrus::devices::Us4OEM::getTxFirmwareVersion"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1a7ec422eaa568e779abd3f3401f525273"></span><em class="property">virtual</em> uint32 <code class="sig-name descname">getTxFirmwareVersion</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM20getTxFirmwareVersionEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns Tx component firmware version installed on this us4OEM module. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM13getOemVersionEv">
<span id="_CPPv3N5arrus7devices6Us4OEM13getOemVersionEv"></span><span id="_CPPv2N5arrus7devices6Us4OEM13getOemVersionEv"></span><span id="arrus::devices::Us4OEM::getOemVersion"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1a84452aaf7647acdccf6e8405d1d89a96"></span><em class="property">virtual</em> uint32_t <code class="sig-name descname">getOemVersion</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM13getOemVersionEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns OEM version (OEM/OEM+) </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM16getFPGAWallclockEv">
<span id="_CPPv3N5arrus7devices6Us4OEM16getFPGAWallclockEv"></span><span id="_CPPv2N5arrus7devices6Us4OEM16getFPGAWallclockEv"></span><span id="arrus::devices::Us4OEM::getFPGAWallclock"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1a47f56ca966c0dd489f16904ccd6f7023"></span><em class="property">virtual</em> float <code class="sig-name descname">getFPGAWallclock</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM16getFPGAWallclockEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns current FPGA wall clock (time passed since Init function was called).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>FPGA wall clock (seconds) </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM24setLnaHpfCornerFrequencyE8uint32_t">
<span id="_CPPv3N5arrus7devices6Us4OEM24setLnaHpfCornerFrequencyE8uint32_t"></span><span id="_CPPv2N5arrus7devices6Us4OEM24setLnaHpfCornerFrequencyE8uint32_t"></span><span id="arrus::devices::Us4OEM::setLnaHpfCornerFrequency__uint32_t"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1a00d1cef400ce83f4edf26e14802bcaab"></span><em class="property">virtual</em> void <code class="sig-name descname">setLnaHpfCornerFrequency</code><span class="sig-paren">(</span>uint32_t <em>frequency</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM24setLnaHpfCornerFrequencyE8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Enables LNA analog high-pass filter and sets a given corner frequency.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>frequency</strong> – LNA high-pass filter corner frequency to set </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM13disableLnaHpfEv">
<span id="_CPPv3N5arrus7devices6Us4OEM13disableLnaHpfEv"></span><span id="_CPPv2N5arrus7devices6Us4OEM13disableLnaHpfEv"></span><span id="arrus::devices::Us4OEM::disableLnaHpf"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1a873313d6e807bf6b12f92b45a87a81c7"></span><em class="property">virtual</em> void <code class="sig-name descname">disableLnaHpf</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM13disableLnaHpfEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Disables LNA analog high-pass filter. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM24setAdcHpfCornerFrequencyE8uint32_t">
<span id="_CPPv3N5arrus7devices6Us4OEM24setAdcHpfCornerFrequencyE8uint32_t"></span><span id="_CPPv2N5arrus7devices6Us4OEM24setAdcHpfCornerFrequencyE8uint32_t"></span><span id="arrus::devices::Us4OEM::setAdcHpfCornerFrequency__uint32_t"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1a88ad4f9b4abfecd5cc719b94f348e486"></span><em class="property">virtual</em> void <code class="sig-name descname">setAdcHpfCornerFrequency</code><span class="sig-paren">(</span>uint32_t <em>frequency</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM24setAdcHpfCornerFrequencyE8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Enables ADC digital high-pass filter and sets a given corner frequency.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>frequency</strong> – ADC high-pass filter corner frequency to set </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM13disableAdcHpfEv">
<span id="_CPPv3N5arrus7devices6Us4OEM13disableAdcHpfEv"></span><span id="_CPPv2N5arrus7devices6Us4OEM13disableAdcHpfEv"></span><span id="arrus::devices::Us4OEM::disableAdcHpf"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1a342076094933ec9264ad43c9da3598b6"></span><em class="property">virtual</em> void <code class="sig-name descname">disableAdcHpf</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM13disableAdcHpfEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Disables ADC digital high-pass filter. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM15getSerialNumberEv">
<span id="_CPPv3N5arrus7devices6Us4OEM15getSerialNumberEv"></span><span id="_CPPv2N5arrus7devices6Us4OEM15getSerialNumberEv"></span><span id="arrus::devices::Us4OEM::getSerialNumber"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1a74716b276bf0e5bd319c6b8a7435a69f"></span><em class="property">virtual</em> <em class="property">const</em> char *<code class="sig-name descname">getSerialNumber</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM15getSerialNumberEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns serial number of this us4OEM (a null-terminated string). </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM11getRevisionEv">
<span id="_CPPv3N5arrus7devices6Us4OEM11getRevisionEv"></span><span id="_CPPv2N5arrus7devices6Us4OEM11getRevisionEv"></span><span id="arrus::devices::Us4OEM::getRevision"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1abb5f879b0fa0db77797d10a77bc761dc"></span><em class="property">virtual</em> <em class="property">const</em> char *<code class="sig-name descname">getRevision</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM11getRevisionEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns revision number of this us4OEM (a null-terminated string). </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM18getHVPSMeasurementEv">
<span id="_CPPv3N5arrus7devices6Us4OEM18getHVPSMeasurementEv"></span><span id="_CPPv2N5arrus7devices6Us4OEM18getHVPSMeasurementEv"></span><span id="arrus::devices::Us4OEM::getHVPSMeasurement"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1ab06a0cda95d8964cd5aa5d610b1e9727"></span><em class="property">virtual</em> HVPSMeasurement <code class="sig-name descname">getHVPSMeasurement</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM18getHVPSMeasurementEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns HVPS ADC measurements </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM22setHVPSSyncMeasurementE8uint16_tf">
<span id="_CPPv3N5arrus7devices6Us4OEM22setHVPSSyncMeasurementE8uint16_tf"></span><span id="_CPPv2N5arrus7devices6Us4OEM22setHVPSSyncMeasurementE8uint16_tf"></span><span id="arrus::devices::Us4OEM::setHVPSSyncMeasurement__uint16_t.float"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1a6838d7aaa4047a10272c7e4330599684"></span><em class="property">virtual</em> float <code class="sig-name descname">setHVPSSyncMeasurement</code><span class="sig-paren">(</span>uint16_t <em>nSamples</em>, float <em>frequency</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM22setHVPSSyncMeasurementE8uint16_tf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Configures HVPS voltage/current measurement in Sync mode.</p>
<p>:param nSamples: number of ADC samples to acquire. :param frequency: Requested sampling frequency. :return: Actual sampling frequency </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM29setWaitForHVPSMeasurementDoneEv">
<span id="_CPPv3N5arrus7devices6Us4OEM29setWaitForHVPSMeasurementDoneEv"></span><span id="_CPPv2N5arrus7devices6Us4OEM29setWaitForHVPSMeasurementDoneEv"></span><span id="arrus::devices::Us4OEM::setWaitForHVPSMeasurementDone"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1ad3fc889f2f760cb34870c8cd826ef431"></span><em class="property">virtual</em> void <code class="sig-name descname">setWaitForHVPSMeasurementDone</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM29setWaitForHVPSMeasurementDoneEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Configures the system to sync with the HVPS Measurement done irq. This method is intended to be used in the probe_check implementation. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM26waitForHVPSMeasurementDoneENSt8optionalIxEE">
<span id="_CPPv3N5arrus7devices6Us4OEM26waitForHVPSMeasurementDoneENSt8optionalIxEE"></span><span id="_CPPv2N5arrus7devices6Us4OEM26waitForHVPSMeasurementDoneENSt8optionalIxEE"></span><span id="arrus::devices::Us4OEM::waitForHVPSMeasurementDone__std::optional:l-l:"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1a072ed6f8cf5161812cb9057bbb1a6306"></span><em class="property">virtual</em> void <code class="sig-name descname">waitForHVPSMeasurementDone</code><span class="sig-paren">(</span>std::optional&lt;long long&gt; <em>timeout</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM26waitForHVPSMeasurementDoneENSt8optionalIxEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Waits for the HVPS Measurement done irq. This method is intended to be used in the probe_check implementation. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM20getActualTxFrequencyEf">
<span id="_CPPv3N5arrus7devices6Us4OEM20getActualTxFrequencyEf"></span><span id="_CPPv2N5arrus7devices6Us4OEM20getActualTxFrequencyEf"></span><span id="arrus::devices::Us4OEM::getActualTxFrequency__float"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1a83b1e9ab43626686d04aab07919dacab"></span><em class="property">virtual</em> float <code class="sig-name descname">getActualTxFrequency</code><span class="sig-paren">(</span>float <em>frequency</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM20getActualTxFrequencyEf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the system TX frequency that would be actually set for the given TX frequency. The output frequency depends on the frequency discretization performed by the driver.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>frequency</strong> – input frequency </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the actual frequency that will be set </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices6Us4OEM10getVariantEv">
<span id="_CPPv3N5arrus7devices6Us4OEM10getVariantEv"></span><span id="_CPPv2N5arrus7devices6Us4OEM10getVariantEv"></span><span id="arrus::devices::Us4OEM::getVariant"></span><span class="target" id="classarrus_1_1devices_1_1Us4OEM_1a029fc94e3d1331008cdb8d6429c0cfc2"></span><em class="property">virtual</em> Variant <code class="sig-name descname">getVariant</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus7devices6Us4OEM10getVariantEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the variant of OEM. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrus7devices9HVVoltageE">
<span id="_CPPv3N5arrus7devices9HVVoltageE"></span><span id="_CPPv2N5arrus7devices9HVVoltageE"></span><span id="arrus::devices::HVVoltage"></span><span class="target" id="classarrus_1_1devices_1_1HVVoltage"></span><em class="property">class </em><code class="sig-prename descclassname">arrus::devices<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">HVVoltage</code><a class="headerlink" href="#_CPPv4N5arrus7devices9HVVoltageE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>HV voltage curve description. Can be specified only by voltage negative and positive amplitude values. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices9HVVoltage9HVVoltageEK7VoltageK7Voltage">
<span id="_CPPv3N5arrus7devices9HVVoltage9HVVoltageEK7VoltageK7Voltage"></span><span id="_CPPv2N5arrus7devices9HVVoltage9HVVoltageEK7VoltageK7Voltage"></span><span id="arrus::devices::HVVoltage::HVVoltage__VoltageC.VoltageC"></span><span class="target" id="classarrus_1_1devices_1_1HVVoltage_1a73f388af89aaca42672c79d13cc4fe82"></span><em class="property">inline</em> <code class="sig-name descname">HVVoltage</code><span class="sig-paren">(</span><em class="property">const</em> Voltage <em>voltageMinus</em>, <em class="property">const</em> Voltage <em>voltagePlus</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrus7devices9HVVoltage9HVVoltageEK7VoltageK7Voltage" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>HV Voltage constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voltageMinus</strong> – negative voltage to set [V] </p></li>
<li><p><strong>voltagePlus</strong> – positive voltage to set [V] </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="output-data">
<h2>Output data<a class="headerlink" href="#output-data" title="Permalink to this headline">¶</a></h2>
<p>An instance of the following class is returned by the <code class="docutils literal notranslate"><span class="pre">sesion.upload</span></code> function:</p>
<dl class="cpp class">
<dt id="_CPPv4N5arrus7session12UploadResultE">
<span id="_CPPv3N5arrus7session12UploadResultE"></span><span id="_CPPv2N5arrus7session12UploadResultE"></span><span id="arrus::session::UploadResult"></span><span class="target" id="classarrus_1_1session_1_1UploadResult"></span><em class="property">class </em><code class="sig-prename descclassname">arrus::session<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">UploadResult</code><a class="headerlink" href="#_CPPv4N5arrus7session12UploadResultE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Scheme upload result. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4NK5arrus7session12UploadResult9getBufferEv">
<span id="_CPPv3NK5arrus7session12UploadResult9getBufferEv"></span><span id="_CPPv2NK5arrus7session12UploadResult9getBufferEv"></span><span id="arrus::session::UploadResult::getBufferC"></span><span class="target" id="classarrus_1_1session_1_1UploadResult_1a95675bae27a6fb5f56b1685d440974a9"></span><em class="property">inline</em> <em class="property">const</em> std::shared_ptr&lt;framework::Buffer&gt; &amp;<code class="sig-name descname">getBuffer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrus7session12UploadResult9getBufferEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a pointer to the ouptput data buffer. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus7session12UploadResult16getConstMetadataE7ArrayId">
<span id="_CPPv3NK5arrus7session12UploadResult16getConstMetadataE7ArrayId"></span><span id="_CPPv2NK5arrus7session12UploadResult16getConstMetadataE7ArrayId"></span><span id="arrus::session::UploadResult::getConstMetadata__ArrayIdC"></span><span class="target" id="classarrus_1_1session_1_1UploadResult_1ac41dc249a5dc241e2a4c41a0fdf16078"></span><em class="property">inline</em> <em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrus7session8MetadataE" title="arrus::session::Metadata">Metadata</a>&gt; &amp;<code class="sig-name descname">getConstMetadata</code><span class="sig-paren">(</span>ArrayId <em>id</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrus7session12UploadResult16getConstMetadataE7ArrayId" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a pointer to the upload constant metadata (desription of the data produced by the system). </p>
</dd></dl>

</div>
</dd></dl>

<p>Upload result can include some additional information (metadata) about the acquired data:</p>
<dl class="cpp class">
<dt id="_CPPv4N5arrus7session8MetadataE">
<span id="_CPPv3N5arrus7session8MetadataE"></span><span id="_CPPv2N5arrus7session8MetadataE"></span><span id="arrus::session::Metadata"></span><span class="target" id="classarrus_1_1session_1_1Metadata"></span><em class="property">class </em><code class="sig-prename descclassname">arrus::session<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">Metadata</code><a class="headerlink" href="#_CPPv4N5arrus7session8MetadataE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A container for all information related to the acquired data.</p>
<p>Currently it is assumed, that the values stored in this class won’t change during system run (is constant). </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4I0EN5arrus7session8Metadata3getENSt10shared_ptrI1TEERKNSt6stringE">
<span id="_CPPv3I0EN5arrus7session8Metadata3getERKNSt6stringE"></span><span id="_CPPv2I0EN5arrus7session8Metadata3getERKNSt6stringE"></span>template&lt;typename <code class="sig-name descname">T</code>&gt;<br /><span class="target" id="classarrus_1_1session_1_1Metadata_1ae8b75b9ee89683bded37eb88d40f027d"></span><em class="property">inline</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4I0EN5arrus7session8Metadata3getENSt10shared_ptrI1TEERKNSt6stringE" title="arrus::session::Metadata::get::T">T</a>&gt; <code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN5arrus7session8Metadata3getENSt10shared_ptrI1TEERKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns metadata for the given key.</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters</dt>
<dd class="field-odd"><p><strong>T</strong> – output type </p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p><strong>key</strong> – metadata key </p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>metadata value for given key </p>
</dd>
</dl>
</dd></dl>

</div>
</dd></dl>

<p>Currently uploading scheme for the Us4R device returns a metadata with a
key <code class="docutils literal notranslate"><span class="pre">frameChannelMapping</span></code>; the metadata value type is:</p>
<dl class="cpp class">
<dt id="_CPPv4N5arrus7devices19FrameChannelMappingE">
<span id="_CPPv3N5arrus7devices19FrameChannelMappingE"></span><span id="_CPPv2N5arrus7devices19FrameChannelMappingE"></span><span id="arrus::devices::FrameChannelMapping"></span><span class="target" id="classarrus_1_1devices_1_1FrameChannelMapping"></span><em class="property">class </em><code class="sig-prename descclassname">arrus::devices<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">FrameChannelMapping</code><a class="headerlink" href="#_CPPv4N5arrus7devices19FrameChannelMappingE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Frame channel mapping: logical (frame, channel) -&gt; physical (frame, channel) </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4NK5arrus7devices19FrameChannelMapping10getLogicalE11FrameNumber10ChannelIdx">
<span id="_CPPv3NK5arrus7devices19FrameChannelMapping10getLogicalE11FrameNumber10ChannelIdx"></span><span id="_CPPv2NK5arrus7devices19FrameChannelMapping10getLogicalE11FrameNumber10ChannelIdx"></span><span id="arrus::devices::FrameChannelMapping::getLogical__FrameNumber.ChannelIdxC"></span><span class="target" id="classarrus_1_1devices_1_1FrameChannelMapping_1af90039d5b6b1fa98613d2e38c18e7ca9"></span><em class="property">virtual</em> FrameChannelMappingAddress <code class="sig-name descname">getLogical</code><span class="sig-paren">(</span>FrameNumber <em>frame</em>, ChannelIdx <em>channel</em><span class="sig-paren">)</span> <em class="property">const</em> = 0<a class="headerlink" href="#_CPPv4NK5arrus7devices19FrameChannelMapping10getLogicalE11FrameNumber10ChannelIdx" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns us4oem module number, physical frame number and channel number for a given, logical, frame number and an <strong>rx aperture</strong> channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frame</strong> – logical frame number </p></li>
<li><p><strong>channel</strong> – logical channel number </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a tuple: us4oem module number, frame number (within a single sequence), channel number </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus7devices19FrameChannelMapping13getFirstFrameEN5arrus5uint8E">
<span id="_CPPv3NK5arrus7devices19FrameChannelMapping13getFirstFrameEN5arrus5uint8E"></span><span id="_CPPv2NK5arrus7devices19FrameChannelMapping13getFirstFrameEN5arrus5uint8E"></span><span id="arrus::devices::FrameChannelMapping::getFirstFrame__arrus::uint8C"></span><span class="target" id="classarrus_1_1devices_1_1FrameChannelMapping_1a1c00174b345ea1bd79d25860ea064926"></span><em class="property">virtual</em> arrus::uint32 <code class="sig-name descname">getFirstFrame</code><span class="sig-paren">(</span>arrus::uint8 <em>us4oem</em><span class="sig-paren">)</span> <em class="property">const</em> = 0<a class="headerlink" href="#_CPPv4NK5arrus7devices19FrameChannelMapping13getFirstFrameEN5arrus5uint8E" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of frame where the given us4OEM data starts. The frame number is computed taking into account the batch size and the number of frames in the sequence of data produced by preceding us4OEM modules. That is, assuming the same number of samples is acquired in each RF frame, you can get the address where us4oem data starts using the following formula: the frame number * number of samples * 32 (number of us4OEM RX channels).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>us4oem</strong> – us4oem ordinal number (0, 1, …) </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the number of frame, which starts portion of data acquired by the given us4OEM. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus7devices19FrameChannelMapping15getFrameOffsetsEv">
<span id="_CPPv3NK5arrus7devices19FrameChannelMapping15getFrameOffsetsEv"></span><span id="_CPPv2NK5arrus7devices19FrameChannelMapping15getFrameOffsetsEv"></span><span id="arrus::devices::FrameChannelMapping::getFrameOffsetsC"></span><span class="target" id="classarrus_1_1devices_1_1FrameChannelMapping_1a38465d09dfa44e494f2a3db938b42f73"></span><em class="property">virtual</em> <em class="property">const</em> std::vector&lt;uint32&gt; &amp;<code class="sig-name descname">getFrameOffsets</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> = 0<a class="headerlink" href="#_CPPv4NK5arrus7devices19FrameChannelMapping15getFrameOffsetsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the list of frame offsets (‘position of first us4oem frame’). See <code class="docutils literal notranslate"><span class="pre">getFirstFrame</span></code> for more information. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus7devices19FrameChannelMapping17getNumberOfFramesE5uint8">
<span id="_CPPv3NK5arrus7devices19FrameChannelMapping17getNumberOfFramesE5uint8"></span><span id="_CPPv2NK5arrus7devices19FrameChannelMapping17getNumberOfFramesE5uint8"></span><span id="arrus::devices::FrameChannelMapping::getNumberOfFrames__uint8C"></span><span class="target" id="classarrus_1_1devices_1_1FrameChannelMapping_1a13fa7b18c919ec7a5692447fdf318819"></span><em class="property">virtual</em> uint32 <code class="sig-name descname">getNumberOfFrames</code><span class="sig-paren">(</span>uint8 <em>us4oem</em><span class="sig-paren">)</span> <em class="property">const</em> = 0<a class="headerlink" href="#_CPPv4NK5arrus7devices19FrameChannelMapping17getNumberOfFramesE5uint8" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of frames that this us4OEM will transfer to the host device.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>us4oem</strong> – us4OEM ordinal number. </p>
</dd>
</dl>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-static-functions">Public Static Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrus7devices19FrameChannelMapping20isChannelUnavailableE4int8">
<span id="_CPPv3N5arrus7devices19FrameChannelMapping20isChannelUnavailableE4int8"></span><span id="_CPPv2N5arrus7devices19FrameChannelMapping20isChannelUnavailableE4int8"></span><span id="arrus::devices::FrameChannelMapping::isChannelUnavailable__int8"></span><span class="target" id="classarrus_1_1devices_1_1FrameChannelMapping_1ad6e2c108835f263caa1b5ce577ed29a7"></span><em class="property">static</em> <em class="property">inline</em> bool <code class="sig-name descname">isChannelUnavailable</code><span class="sig-paren">(</span>int8 <em>channelNumber</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrus7devices19FrameChannelMapping20isChannelUnavailableE4int8" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if the given PHYSICAL channel number is unavailable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>channelNumber</strong> – physical channel number to verify. </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>true if given channel is unavailable, false otherwise </p>
</dd>
</dl>
</dd></dl>

</div>
</dd></dl>

<p>Upload result contains also a handle to the output data buffer.</p>
<dl class="cpp class">
<dt id="_CPPv4N5arrus9framework10DataBufferE">
<span id="_CPPv3N5arrus9framework10DataBufferE"></span><span id="_CPPv2N5arrus9framework10DataBufferE"></span><span id="arrus::framework::DataBuffer"></span><span class="target" id="classarrus_1_1framework_1_1DataBuffer"></span><em class="property">class </em><code class="sig-prename descclassname">arrus::framework<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">DataBuffer</code> : <em class="property">public</em> arrus::framework::Buffer<a class="headerlink" href="#_CPPv4N5arrus9framework10DataBufferE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A data buffer. This interface allows to register callback function to be called when new data arrives. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrus9framework10DataBuffer25registerOnNewDataCallbackER17OnNewDataCallback">
<span id="_CPPv3N5arrus9framework10DataBuffer25registerOnNewDataCallbackER17OnNewDataCallback"></span><span id="_CPPv2N5arrus9framework10DataBuffer25registerOnNewDataCallbackER17OnNewDataCallback"></span><span id="arrus::framework::DataBuffer::registerOnNewDataCallback__OnNewDataCallbackR"></span><span class="target" id="classarrus_1_1framework_1_1DataBuffer_1af60ea16d165913651bc895ebda5e4ac1"></span><em class="property">virtual</em> void <code class="sig-name descname">registerOnNewDataCallback</code><span class="sig-paren">(</span>OnNewDataCallback &amp;<em>callback</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus9framework10DataBuffer25registerOnNewDataCallbackER17OnNewDataCallback" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Registers callback, that should be called once new data arrives at the buffer head. The callback has an access to the latest data.</p>
<p>Free the provided buffer element using <code class="docutils literal notranslate"><span class="pre">release</span></code> function when the data is no longer needed.</p>
<p>The callback is required. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus9framework10DataBuffer26registerOnOverflowCallbackER18OnOverflowCallback">
<span id="_CPPv3N5arrus9framework10DataBuffer26registerOnOverflowCallbackER18OnOverflowCallback"></span><span id="_CPPv2N5arrus9framework10DataBuffer26registerOnOverflowCallbackER18OnOverflowCallback"></span><span id="arrus::framework::DataBuffer::registerOnOverflowCallback__OnOverflowCallbackR"></span><span class="target" id="classarrus_1_1framework_1_1DataBuffer_1ae182ff300ce7001d16e8b00d76d2e6eb"></span><em class="property">virtual</em> void <code class="sig-name descname">registerOnOverflowCallback</code><span class="sig-paren">(</span>OnOverflowCallback &amp;<em>callback</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus9framework10DataBuffer26registerOnOverflowCallbackER18OnOverflowCallback" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Registers callback, that will be called once buffer overflow happens.</p>
<p>The callback function is optional, by default nop is performed. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus9framework10DataBuffer24registerShutdownCallbackER18OnShutdownCallback">
<span id="_CPPv3N5arrus9framework10DataBuffer24registerShutdownCallbackER18OnShutdownCallback"></span><span id="_CPPv2N5arrus9framework10DataBuffer24registerShutdownCallbackER18OnShutdownCallback"></span><span id="arrus::framework::DataBuffer::registerShutdownCallback__OnShutdownCallbackR"></span><span class="target" id="classarrus_1_1framework_1_1DataBuffer_1a54ccfe16285da27954854ac89359bae7"></span><em class="property">virtual</em> void <code class="sig-name descname">registerShutdownCallback</code><span class="sig-paren">(</span>OnShutdownCallback &amp;<em>callback</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus9framework10DataBuffer24registerShutdownCallbackER18OnShutdownCallback" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Registers callback, that will be called once buffer is shutdown.</p>
<p>Buffer shutdown is preformed when the device is stopped. The callback function is optional, by default nop is set. </p>
</dd></dl>

</div>
</dd></dl>

<p>Data buffers consists of multiple elements.</p>
<dl class="cpp class">
<dt id="_CPPv4N5arrus9framework13BufferElementE">
<span id="_CPPv3N5arrus9framework13BufferElementE"></span><span id="_CPPv2N5arrus9framework13BufferElementE"></span><span id="arrus::framework::BufferElement"></span><span class="target" id="classarrus_1_1framework_1_1BufferElement"></span><em class="property">class </em><code class="sig-prename descclassname">arrus::framework<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">BufferElement</code><a class="headerlink" href="#_CPPv4N5arrus9framework13BufferElementE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A buffer element. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrus9framework13BufferElement7getDataE7ArrayId">
<span id="_CPPv3N5arrus9framework13BufferElement7getDataE7ArrayId"></span><span id="_CPPv2N5arrus9framework13BufferElement7getDataE7ArrayId"></span><span id="arrus::framework::BufferElement::getData__ArrayId"></span><span class="target" id="classarrus_1_1framework_1_1BufferElement_1a2df158f51ead3d23ef5e7bcee8f84d9d"></span><em class="property">virtual</em> <a class="reference internal" href="#_CPPv4N5arrus9framework7NdArrayE" title="arrus::framework::NdArray">NdArray</a> &amp;<code class="sig-name descname">getData</code><span class="sig-paren">(</span>ArrayId <em>id</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus9framework13BufferElement7getDataE7ArrayId" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns output data, with the given id (ordinal).</p>
<p>In some cases (e.g. when running a sequence of TX/RX sequences) the system/process can produce a tuple of arrays. This method is kept for backward compatibility, and always gives the access to the first element of the tuple.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#classarrus_1_1framework_1_1NdArray"><span class="std std-ref">NdArray</span></a> with data </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus9framework13BufferElement7getDataEv">
<span id="_CPPv3N5arrus9framework13BufferElement7getDataEv"></span><span id="_CPPv2N5arrus9framework13BufferElement7getDataEv"></span><span id="arrus::framework::BufferElement::getData"></span><span class="target" id="classarrus_1_1framework_1_1BufferElement_1a2a2e92b39d5311e9b4a44da72394f689"></span><em class="property">virtual</em> <a class="reference internal" href="#_CPPv4N5arrus9framework7NdArrayE" title="arrus::framework::NdArray">NdArray</a> &amp;<code class="sig-name descname">getData</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus9framework13BufferElement7getDataEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns output data, with the ordinal 0.</p>
<p>See also <a class="reference internal" href="#classarrus_1_1framework_1_1BufferElement_1a2df158f51ead3d23ef5e7bcee8f84d9d"><span class="std std-ref">getData(ArrayId ordinal)</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#classarrus_1_1framework_1_1NdArray"><span class="std std-ref">NdArray</span></a> with data </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus9framework13BufferElement7getSizeEv">
<span id="_CPPv3N5arrus9framework13BufferElement7getSizeEv"></span><span id="_CPPv2N5arrus9framework13BufferElement7getSizeEv"></span><span id="arrus::framework::BufferElement::getSize"></span><span class="target" id="classarrus_1_1framework_1_1BufferElement_1a2b30c9e6971a7fd9886d46da7561ba45"></span><em class="property">virtual</em> size_t <code class="sig-name descname">getSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus9framework13BufferElement7getSizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the size of this buffer element.</p>
<p>NOTE: the size is equal to the sum of the sizes of all subelements (e.g. in case of an element that stores a tuple of NdArrays, this method will return the sum of all NdArrays in that tuple).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>size of the whole element in bytes </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus9framework13BufferElement11getPositionEv">
<span id="_CPPv3N5arrus9framework13BufferElement11getPositionEv"></span><span id="_CPPv2N5arrus9framework13BufferElement11getPositionEv"></span><span id="arrus::framework::BufferElement::getPosition"></span><span class="target" id="classarrus_1_1framework_1_1BufferElement_1a4e4945b32ae65bbbfb05f5be666b413c"></span><em class="property">virtual</em> size_t <code class="sig-name descname">getPosition</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrus9framework13BufferElement11getPositionEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns position of the element in the data buffer. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus9framework13BufferElement17getNumberOfArraysEv">
<span id="_CPPv3NK5arrus9framework13BufferElement17getNumberOfArraysEv"></span><span id="_CPPv2NK5arrus9framework13BufferElement17getNumberOfArraysEv"></span><span id="arrus::framework::BufferElement::getNumberOfArraysC"></span><span class="target" id="classarrus_1_1framework_1_1BufferElement_1a94a41a9eaaa4b52c50ae609b2dc12f0c"></span><em class="property">virtual</em> uint16 <code class="sig-name descname">getNumberOfArrays</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> = 0<a class="headerlink" href="#_CPPv4NK5arrus9framework13BufferElement17getNumberOfArraysEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of arrays each element of this buffer contains. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrus9framework7NdArrayE">
<span id="_CPPv3N5arrus9framework7NdArrayE"></span><span id="_CPPv2N5arrus9framework7NdArrayE"></span><span id="arrus::framework::NdArray"></span><span class="target" id="classarrus_1_1framework_1_1NdArray"></span><em class="property">class </em><code class="sig-prename descclassname">arrus::framework<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">NdArray</code><a class="headerlink" href="#_CPPv4N5arrus9framework7NdArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>N-dimensional array.</p>
<p>The data order in memory is C-contiguous (last axis varies the fastest).</p>
<p>The address returned by <code class="docutils literal notranslate"><span class="pre">getData</span></code> function is located on a device determined by placement property. CPU:0 placement means that the data is located in host computer’s RAM. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-types">Public Types</p>
<dl class="cpp type">
<dt id="_CPPv4N5arrus9framework7NdArray8DataTypeE">
<span id="_CPPv3N5arrus9framework7NdArray8DataTypeE"></span><span id="_CPPv2N5arrus9framework7NdArray8DataTypeE"></span><span class="target" id="classarrus_1_1framework_1_1NdArray_1a9481796d70a68eb4faf91039e0d86538"></span><em class="property">using </em><code class="sig-name descname">DataType</code> = NdArrayDef::DataType<a class="headerlink" href="#_CPPv4N5arrus9framework7NdArray8DataTypeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A list of currently supported data types of the output buffer. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4I0EN5arrus9framework7NdArray3getEP1Tv">
<span id="_CPPv3I0EN5arrus9framework7NdArray3getEv"></span><span id="_CPPv2I0EN5arrus9framework7NdArray3getEv"></span>template&lt;typename <code class="sig-name descname">T</code>&gt;<br /><span class="target" id="classarrus_1_1framework_1_1NdArray_1a51e96657578096523c069c7f4a350257"></span><em class="property">inline</em> <a class="reference internal" href="#_CPPv4I0EN5arrus9framework7NdArray3getEP1Tv" title="arrus::framework::NdArray::get::T">T</a> *<code class="sig-name descname">get</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN5arrus9framework7NdArray3getEP1Tv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a pointer to data.</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters</dt>
<dd class="field-odd"><p><strong>T</strong> – data type </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a pointer to data </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I0ENK5arrus9framework7NdArray3getEPK1Tv">
<span id="_CPPv3I0ENK5arrus9framework7NdArray3getEv"></span><span id="_CPPv2I0ENK5arrus9framework7NdArray3getEv"></span>template&lt;typename <code class="sig-name descname">T</code>&gt;<br /><span class="target" id="classarrus_1_1framework_1_1NdArray_1ad3ab827a212e855f4599ce614ccc73c6"></span><em class="property">inline</em> <em class="property">const</em> <a class="reference internal" href="#_CPPv4I0ENK5arrus9framework7NdArray3getEPK1Tv" title="arrus::framework::NdArray::get::T">T</a> *<code class="sig-name descname">get</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4I0ENK5arrus9framework7NdArray3getEPK1Tv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a pointer to data.</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters</dt>
<dd class="field-odd"><p><strong>T</strong> – data type </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a pointer to data </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus9framework7NdArray8getInt16Ev">
<span id="_CPPv3N5arrus9framework7NdArray8getInt16Ev"></span><span id="_CPPv2N5arrus9framework7NdArray8getInt16Ev"></span><span id="arrus::framework::NdArray::getInt16"></span><span class="target" id="classarrus_1_1framework_1_1NdArray_1a8d7152bb88767bff8d96429695a092d4"></span><em class="property">inline</em> short *<code class="sig-name descname">getInt16</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrus9framework7NdArray8getInt16Ev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a pointer to the memory data (assuming the data type is int16). </p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus9framework7NdArray5sliceE6size_tii">
<span id="_CPPv3NK5arrus9framework7NdArray5sliceE6size_tii"></span><span id="_CPPv2NK5arrus9framework7NdArray5sliceE6size_tii"></span><span id="arrus::framework::NdArray::slice__s.i.iC"></span><span class="target" id="classarrus_1_1framework_1_1NdArray_1aa6a593c81a5f6d0988b27114877681f7"></span><em class="property">inline</em> <a class="reference internal" href="#_CPPv4N5arrus9framework7NdArrayE" title="arrus::framework::NdArray">NdArray</a> <code class="sig-name descname">slice</code><span class="sig-paren">(</span>size_t <em>i</em>, int <em>begin</em>, int <em>end</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrus9framework7NdArray5sliceE6size_tii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a view to this array limited to begin:end on the index i. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus9framework7NdArray3rowE6size_t">
<span id="_CPPv3NK5arrus9framework7NdArray3rowE6size_t"></span><span id="_CPPv2NK5arrus9framework7NdArray3rowE6size_t"></span><span id="arrus::framework::NdArray::row__sC"></span><span class="target" id="classarrus_1_1framework_1_1NdArray_1ac528a294acf5baf40d2389736785dd61"></span><em class="property">inline</em> <a class="reference internal" href="#_CPPv4N5arrus9framework7NdArrayE" title="arrus::framework::NdArray">NdArray</a> <code class="sig-name descname">row</code><span class="sig-paren">(</span>size_t <em>value</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrus9framework7NdArray3rowE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a view to this array with axis=0 set to the given value. For example, to get the jth row: array.row(j). </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4I0EN5arrus5TupleE">
<span id="_CPPv3I0EN5arrus5TupleE"></span><span id="_CPPv2I0EN5arrus5TupleE"></span>template&lt;typename <code class="sig-name descname">T</code>&gt;<br /><span class="target" id="classarrus_1_1Tuple"></span><em class="property">class </em><code class="sig-prename descclassname">arrus<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">Tuple</code><a class="headerlink" href="#_CPPv4I0EN5arrus5TupleE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A tuple of values.</p>
<p>Note: this class is immutable. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4NK5arrus5TupleixE6size_t">
<span id="_CPPv3NK5arrus5TupleixE6size_t"></span><span id="_CPPv2NK5arrus5TupleixE6size_t"></span><span id="arrus::Tuple::subscript-operator__sC"></span><span class="target" id="classarrus_1_1Tuple_1ad3706c6814b259287a5a7e8b52f26a40"></span><em class="property">inline</em> <em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EN5arrus5TupleE" title="arrus::Tuple::T">T</a> &amp;<code class="sig-name descname">operator[]</code><span class="sig-paren">(</span>size_t <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrus5TupleixE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns i-th. value. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus5Tuple3getE6size_t">
<span id="_CPPv3NK5arrus5Tuple3getE6size_t"></span><span id="_CPPv2NK5arrus5Tuple3getE6size_t"></span><span id="arrus::Tuple::get__sC"></span><span class="target" id="classarrus_1_1Tuple_1aff01c1e2a623af10853601122ea671ca"></span><em class="property">inline</em> <em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EN5arrus5TupleE" title="arrus::Tuple::T">T</a> &amp;<code class="sig-name descname">get</code><span class="sig-paren">(</span>size_t <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrus5Tuple3getE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns i-th value. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrus5Tuple10getMutableE6size_t">
<span id="_CPPv3N5arrus5Tuple10getMutableE6size_t"></span><span id="_CPPv2N5arrus5Tuple10getMutableE6size_t"></span><span id="arrus::Tuple::getMutable__s"></span><span class="target" id="classarrus_1_1Tuple_1a7f97b0a73362bfc9497b92753d181403"></span><em class="property">inline</em> <a class="reference internal" href="#_CPPv4I0EN5arrus5TupleE" title="arrus::Tuple::T">T</a> &amp;<code class="sig-name descname">getMutable</code><span class="sig-paren">(</span>size_t <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrus5Tuple10getMutableE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns i-th value. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrus5Tuple4sizeEv">
<span id="_CPPv3NK5arrus5Tuple4sizeEv"></span><span id="_CPPv2NK5arrus5Tuple4sizeEv"></span><span id="arrus::Tuple::sizeC"></span><span class="target" id="classarrus_1_1Tuple_1a73d4951b255cefa2d6a91b8ff79cac74"></span><em class="property">inline</em> size_t <code class="sig-name descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrus5Tuple4sizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the tuple size (number of values it consists of). </p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="misc/acknowledgments.html" class="btn btn-neutral float-right" title="Acknowledgments" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="user_guide.html" class="btn btn-neutral float-left" title="User Guide" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2025, us4us Ltd.

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>